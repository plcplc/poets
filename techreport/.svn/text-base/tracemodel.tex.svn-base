\documentclass[orivec,final]{llncs-href}

\usepackage[utf8]{inputenc}
\usepackage[linkbordercolor={0 0 1},breaklinks]{hyperref}
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{amsmath}
\usepackage[numbers,sort]{natbib}
\usepackage{colortbl}
\usepackage{listings}
\usepackage{stmaryrd}
\usepackage{paralist}
\usepackage[draft]{fixme}
\usepackage{ifthen}
\usepackage{refcount}

% Domains
\newcommand{\nat}{\mathbb{N}}
\newcommand{\actionkindset}{\mathcal{K}}
\newcommand{\typeset}{\mathcal{T}}
\newcommand{\actionset}{\mathcal{A}}
\newcommand{\timeset}{\mathbb{T}}
\newcommand{\agentset}{\mathbb{A}}
\newcommand{\eventset}[1]{\mathbb{E}_{#1}}
\newcommand{\traceset}[1]{\mathit{Tr}_{#1}}
\newcommand{\verdictset}[1]{\mathbb{V}^{#1}}
\newcommand{\verdictsetlift}[1]{\verdictset{#1}_{\bot}}
\newcommand{\contractset}[1]{\traceset{#1} \to \verdictset{#1}}
\newcommand{\contractsetlift}[1]{\traceset{#1} \to \verdictsetlift{#1}}
\newcommand{\templatenameset}{\mathcal{F}}

% Functions
\newcommand{\tp}{\mathsf{ar}}
\newcommand{\dom}[1]{\mathrm{dom}(#1)}
\newcommand{\cod}[1]{\mathrm{cod}(#1)}
\newcommand{\dendom}[1]{\llbracket #1 \rrbracket}
\newcommand{\dendomlift}[1]{\llbracket #1 \rrbracket^*}
\newcommand{\tracestart}{\mathsf{start}}
\newcommand{\traceend}{\mathsf{end}}
\newcommand{\rmf}{\mathsf{RM}}
\newcommand{\tracesplit}{\mathsf{split}}
\newcommand{\lift}[1]{\lfloor #1 \rfloor}

% Symbols
\newcommand{\trace}{\sigma}
\newcommand{\type}{\tau}
\newcommand{\finsubset}{\subseteq_{\mathrm{fin}}}
\newcommand{\conforming}{\top}
\newcommand{\emptytrace}{\varepsilon}
\newcommand{\emptychoice}{\epsilon}
\newcommand{\choice}{\mathit{lrs}}
\newcommand{\powerset}{\mathcal{P}}
\newcommand{\partialok}{\mathrm{Nullable}}
\newcommand{\inconclusive}{\mathrm{?}}
\newcommand{\contract}{\mathsf{c}}
\newcommand{\proofsep}{\vspace{15pt}}

% Relations
\newcommand{\event}[3]{\langle #1,#2,#3\rangle}

% Contract specification language (CSL) definitions
\newcommand{\csl}{\textit{CSL}}
\newcommand{\varset}{\mathcal{V}}
\newcommand{\ccontract}[3]{\mathsf{letrec}\ #1\ \mathsf{in}\ #2\
  \mathsf{starting}\ #3}
\newcommand{\cempty}{\mathsf{empty}}
\newcommand{\catomic}[6]{\langle#1\rangle\ #2\ \textsf{@}\ #3\
  \mathsf{where}\ #4\ \mathsf{due}\ #5\ \mathsf{then}\ #6}
\newcommand{\catomicp}[7]{\mathsf{if}\ \langle#1\rangle\ #2\ \textsf{@}\ #3\
  \mathsf{where}\ #4\ \mathsf{due}\ #5\ \mathsf{then}\ #6\
  \mathsf{else}\ #7}
\newcommand{\cand}[2]{#1\ \mathsf{and}\ #2}
\newcommand{\cor}[2]{#1\ \mathsf{or}\ #2}
\newcommand{\cifthenelse}[3]{\mathsf{if}\ #1\ \mathsf{then}\ #2\
  \mathsf{else}\ #3}
\newcommand{\cinstantiate}[3]{#1(#2)\langle#3\rangle}

\newcommand{\cwithin}[1]{\mathsf{within}\ #1}
\newcommand{\cwithinafter}[2]{\mathsf{within}\ #1\ \mathsf{after}\ #2}
\newcommand{\cimmediately}{\mathsf{immediately}}
\newcommand{\cimmediatelyafter}[1]{\mathsf{immediately\ after}\ #1}

\newcommand{\ctrue}{\mathsf{true}}
\newcommand{\cfalse}{\mathsf{false}}
\newcommand{\candalso}{\mathsf{andalso}}

\newcommand{\binop}{\mathbin{\mathit{binop}}}
\newcommand{\binrel}{\mathbin{\mathit{binrel}}}

\newcommand{\canddefault}{\cand{c_1}{c_2}}
\newcommand{\cordefault}{\cor{c_1}{c_2}}
\newcommand{\cifthenelsedefault}{\cifthenelse{e}{c_1}{c_2}}
\newcommand{\cinstantiatedefault}{\cinstantiate{f}{\vec{e}}{\vec{e_a}}}

\lstdefinelanguage{csl}
{
 morekeywords={empty,where,due,within,after,immediately,and,or,if,then,else,andalso,letrec,in,starting},
 morecomment=[l]//,
 morecomment=[s]{/*}{*/},
 sensitive=true,
 basicstyle=\scriptsize\ttfamily,
 keywordstyle=\color{blue},
 identifierstyle=,
 commentstyle=\itshape,
 stringstyle=\ttfamily,
 showstringspaces=false,
}

% Environment for writing BNF grammars
\newenvironment{bnf}{\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}r}}{\end{tabular}}
\newcommand{\bnfsep}{\mathbin{|}}

% Environment for rendering paper contracts
\newcounter{paragraphcounter}
\newenvironment{papercontract}
  {\begin{list}{\textbf{Paragraph \arabic{paragraphcounter}.}}{\usecounter{paragraphcounter}\leftmargin=0pt\itemindent=17pt\rightmargin=0pt\topsep=7pt\itemsep=2pt}}
  {\end{list}}
\newcommand{\contractparam}[1]{{\texttt{[#1]}}}

% -- Setup page numbering (not default in LLNCS)
\pagestyle{plain}
\pagenumbering{arabic}

% -- 'Hack' to change the References from a chapter to a section
\makeatletter
\renewcommand\bibsection%
{
  \section*{\refname
    \@mkboth{\MakeUppercase{\refname}}{\MakeUppercase{\refname}}}
}
\makeatother

% -- Referable theorems
% #1: type, #2: label, #3: caption, #4: hint, #5: body
\def\defthm#1#2#3#4#5{
  \expandafter\def\csname refthmhint#2\endcsname{#4} 
  \expandafter\def\csname refthmbody#2\endcsname{#5}
  \expandafter\newcounter{refthmcounter#2}
  \expandafter\setcounterref{refthmcounter#2}{#2}
  \expandafter\addtocounter{refthmcounter#2}{-1}
  \expandafter\spnewtheorem{refthmenv#2}[refthmcounter#2]{#3}{\bfseries}{\itshape}
  \ifthenelse{\equal{}{#4}}
  { 
    \begin{#1}\label{#2}
  }
  {
    \begin{#1}[#4]\label{#2}
  }
    #5
  \end{#1}
}

% -- Reference to a theorem
% #1: label
\def\refthm#1{
  \phantomsection %% Enable this label to be target of hyperref
  \label{proof:#1}
  \ifthenelse{\equal{}{\csname refthmhint#1\endcsname}}
  { 
    \begin{refthmenv#1}[p. \pageref{#1}]
    \csname refthmbody#1\endcsname
    \end{refthmenv#1}
  }
  {
    \begin{refthmenv#1}[\csname refthmhint#1\endcsname, p. \pageref{#1}]
    \csname refthmbody#1\endcsname
    \end{refthmenv#1}
  }
}

\begin{document}
\title{A trace-based model for multi-party contracts\thanks{This work
    was done during the author's internship in the Information
    Security group at ETH Z\"urich.}}
\author{Tom Hvitved}
\institute{Department of Computer Science\\University of
  Copenhagen\\Universitetsparken 1\\DK-2100 Copenhagen, Denmark\\
  \texttt{hvitved@diku.dk}}

\maketitle

\begin{abstract}
  A (multi-party) contract is a legally binding agreement between
  individuals or companies that describes the commitments
  of each contract participant. For enterprises, contracts
  serve as the \emph{external interface} to their clients, and
  consequently it is crucial to \emph{monitor} the execution of these
  contracts for violations, and to \emph{comply} with them in order to
  avoid financial penalties. In this paper we present a trace-based
  model for multi-party contracts, in which contract conformance is
  defined abstractly as a property on traces. A highlight of our model
  is \emph{blame assignment}, which means that all
  contract violations are attributed to contract participants, and we
  analyze how blame assignment affects compositionality. Moreover, in
  order to specify contracts, we introduce a contract specification
  language, \csl{}, which is given a formal semantics by means of a
  mapping into the abstract model, and which overcomes the limitations
  of existing contract languages by supporting
  \begin{inparaenum}[(a)]
  \item (history sensitive and conditional) commitments,
  \item parametrized contract templates,
  \item relative and absolute temporal constraints,
  \item contrary-to-duty obligations,
  \item potentially infinite contracts, and
  \item arithmetic expressions.
  \end{inparaenum}
  Last but not least, \csl{} admits run-time monitoring via rewriting,
  and we also validate \csl{}'s applicability by formalizing several
  example contracts.
\end{abstract}

\section{Introduction}
Empirical studies conducted by the Aberdeen Group
\cite{aberdeen06procurementcontracts,aberdeen07clm} suggest that 
\emph{contract lifecycle management} (CLM) will be a critical key to
success for businesses in the near future. CLM is a broad term used to cover
the activities of systematically and efficiently managing contract
\emph{creation}, contract \emph{negotiation}, contract
\emph{approval}, contract \emph{execution}, and contract
\emph{analysis}. In the Aberdeen Group studies it is
reported that around 80 percent of the surveyed enterprises (220
participants) are exercising only manual, or partially automated
contract management activities, the implication of which is a lower
rate of compliant transactions (i.e., actions according to
contract). This in turn implies potential financial penalties:
\begin{quote}
``[...] the average savings of transactions that are compliant with
contracts is 22\%.'' \cite[p. 1]{aberdeen06procurementcontracts}
\end{quote}

In the more recent context of e-commerce, fully automated CLM is
becoming ever more important, as electronic contracts are initiated
all the time. Current state-of-the-art enterprise systems such as
Microsoft Dynamics
NAV\footnote{\url{http://www.microsoft.com/dynamics/en/us/products/nav-overview.aspx}}
and SAP\footnote{\url{http://www.sap.com}}, only deal with contracts
--- sales, purchases, leasing agreements, employment contracts,
etc. --- implicitly: contracts are not represented as 
first-class objects, but rather they can be derived from the often
customized low-level code and database schemes underlying the
systems. The implications of such implicit encodings are that it is
unclear what exactly is implemented, and whether the
implementation conforms with the actual contracts. Furthermore,
changes in contract templates are often costly and time consuming, and
analyses on (running) contracts are difficult to perform, since they
have to be defined with respect to the implicit encodings.

To overcome these limitations, various authors have proposed domain
specific languages for representing contracts
\cite{lee88electroniccontracting,goodchild00b2b,boulmakoul02integratedcontract,governatori06formalbcl,andersen06contracts,prisacariu07cl,governatori09drcontract},
and also the before mentioned studies by the Aberdeen Group suggest
using a domain specific language as the basis for automated
CLM. However, constructing such domain specific language is a
challenge, since contracts can have many different aspects, such as
absolute temporal constraints (deadlines), relative temporal 
constraints (sequential ordering), contrary-to-duty clauses
\cite{prakken96ctd}, conditional commitments, different deontic
modalities (obligations, permissions, and prohibitions
\cite{wright51deonticlogic}) and repetitive patterns. (See the paper
by Pace and Schneider \cite{pace09challenges} for more elaboration on
these concepts.) In light of these challenges, existing contract
languages fall short on different important aspects, and even only few
contract languages are presented with a formal semantics
\cite{andersen06contracts,prisacariu07cl}. There are several
reasons for wanting to specify contracts in a domain specific
language, e.g., in order to analyze contracts prior to signing them,
as described by Peyton-Jones and Eber \cite{jones03contracts} for
financial contracts. But the most important reason to formalize
contracts is the ability to \emph{run-time monitor} their execution
\cite{leucker09rv}: a formalized contract should be \emph{executable}
with respect to the events relevant to the contract (for instance a
payment by one contract participant to another), and the execution
(monitoring) should report violations by contract participants as they
occur. The aspect of \emph{blame assignment} is a fundamental property
that is not handled by any existing contract languages, even though
run-time monitoring for contracts has been studied extensively
\cite{xu04multipartycontracts,governatori06formalbcl,goodchild00b2b,prisacariu07cl,andersen06contracts,molina04runtimemonitoring}.

Consequently, the motivation for our work is the construction of a
contract language which supports as many of the various contract
features as possible, and which permits run-time monitoring with blame
assignment. However, rather than begininning at the high level of a
contract language and all the features it should support, we must
first analyze what the abstract properties of contracts are 
--- only when we have a \emph{good} abstract mathematical model, which
matches the intuition of contracts, can we consider a language. 
Only few authors have previously considered more abstract contract models
\cite{xu04multipartycontracts,molina04runtimemonitoring,oren09towards},
and among those only Xu \cite{xu04multipartycontracts} considers blame
assignment. However, these models are not fully abstract, since they
rely on for instance deadlines \cite{xu04multipartycontracts}, deontic
modalities \cite{molina04runtimemonitoring} and logical formulae
\cite{oren09towards}. Furthermore, none of the authors have 
constructed contract languages for specifying contracts, which map
into the models.

The approach we take is a \emph{trace-based} model of contracts, which
means that contracts are defined as properties on the history of
actions that have taken place. In other words, we consider contracts 
to be \emph{driven} by the actions performed, similar to Pace and
Schneider \cite{pace09challenges} and Andersen et
al. \cite{andersen06contracts}. Depending on the sequence of actions
that take place, the outcome of a contract can either be fulfillment
(contract \emph{conformance}) or nonfulfillment (contract
\emph{violation}), and such outcome may then for instance be
\emph{suggestive} of an obligation or a deadline not being met --- but the model
does not rely on such high-level notions. As argued above, the
contract must also specify \emph{who} violated the contract in case of
nonfulfillment: in our model, contracts are restricted to
\emph{deterministic} blame assignment, which means that all violations
can uniquely be attributed to contract participants. Even though
deterministic blame assignment is certainly a desirable feature, not
all contracts need be deterministic, but for now we restrict the model
to deterministic blame assignment.
Moreover, in our model, violations are considered 
\emph{fundamental breaches} \cite{wikipedia10fundamentalbreach}, which 
simplified means that a contract is invalid once it is violated, and
we consequently do not model violations at different time
points. (E.g., a contract cannot conclude the violation by one party on
1st of July 2010 and a violation by another party on 1st of August
2010.)

A desirable property in any formalism is \emph{compositionality},
which for contracts means the ability to combine a set of sub
contracts --- typically called paragraphs or clauses --- into one
contract. A highlight of our work is an abstract account of contract
conjunction and contract disjunction, and how these compositions
affect blame assignment. Contract conjunction is evident in nearly all
paper contracts --- typically in the form of a set of implicitly
conjuncted paragraphs --- and we show that contract conjunction can be
given a coherent interpretation. The composition relies on the before
mentioned assumption of fundamental breaches: if a contract contains
two or more paragraphs, which are all violated, then the earliest
violation is the combined verdict. As an example, if a contract
stipulates that a seller must deliver goods to buyer on or before
2010-06-01, and buyer must pay seller on or before 2010-06-15, then if
neither seller delivers nor buyer pays, the combined verdict is that seller has
violated the contract on 2010-06-01.
 Contract disjunction is dual to contract conjunction, which 
means that it is always the last possible violation that is the
combined verdict, but unlike contract conjunction, contract
disjunction can introduce nondeterminism --- even if both sub
contracts are deterministic. In fact this is no surprise, since
disjunction is inherently nondeterministic, however, in the restricted
case where both sub contracts stipulate commitments on the same
contract participant, disjunction will also be a deterministic
operator. In this case disjunction corresponds to a \emph{choice} to
be performed by said contract party, and such choice is indeed
deterministic.

The definition of the abstract contract model and the analysis of
compositonality versus blame assignment provides for a better
understanding of what makes contracts special. However, specifying
contracts directly in the abstract model is not practical.
Consequently, we need a specification language for writing contracts,
which should support as many of the aspects mentioned earlier as
possible, and which can be related to the abstract model via a mapping
of specifications into 
abstract contracts. Furthermore, the language should be amenable to
run-time monitoring, as mentioned earlier. To this end, we propose the language \csl{} (Contract
Specification Language), which overcomes the limitations of previous
contract languages by supporting history sensitive contracts (i.e.,
contracts in which the exact content of commitments can depend on what
has happened in the past)
\cite{governatori06formalbcl,andersen06contracts}, conditional
commitments
\cite{lee88electroniccontracting,governatori06formalbcl,goodchild00b2b,prisacariu07cl,boulmakoul02integratedcontract},
contract templates \cite{andersen06contracts}, 
relative temporal constraints
\cite{lee88electroniccontracting,governatori06formalbcl,goodchild00b2b,andersen06contracts},
absolute temporal constrains
\cite{lee88electroniccontracting,governatori06formalbcl,goodchild00b2b,andersen06contracts,boulmakoul02integratedcontract},
contrary-to-duty/reparation clauses
\cite{governatori06formalbcl,prisacariu07cl,boulmakoul02integratedcontract},
and potentially infinite contracts
\cite{andersen06contracts,prisacariu07cl}. Furthermore, \csl{}
contracts are by construction deterministic, which by virtue of the
mapping into the semantic model means that contract violations can
always be deterministically attributed to contract participants, which
to the best of our knowledge is not incorporated into any existing
contract language. For run-time monitoring of \csl{} contracts, we
define a rewrite-based algorithm, inspired by the algorithm of
Andersen et al. \cite{andersen06contracts}: the current contract
state (i.e., contract specification) and the next event either
rewrites to a residual contract specification, or an indication of contract
violation. The appeal of this approach is that running contracts are
conceptually no different from initial contracts, which entails that
any analysis applicable to initial contracts are also applicable to
running contracts. Finally, we validate the applicability of \csl{} by
formalizing among others, a sales contract, a lease agreement, and an
installment sale.

To summarize, we see our main contributions as follows:
\begin{itemize}
\item We present an abstract, trace-based contract model with
  blame assignment, and analyze the implications compositionality has
  for blame assignment.
\item We introduce a contract specification language, \csl{}, which is
  given a formal semantics in terms of the abstract trace model, and
  which overcomes the limitations of previous contract languages by
  supporting
  \begin{inparaenum}[(a)]
  \item (history sensitive and conditional) commitments,
  \item parametrized contract templates,
  \item relative and absolute temporal constraints,
  \item contrary-to-duty obligations,
  \item potentially infinite contracts,
  \item arithmetic expressions, and
  \item deterministic blame-assignment.
  \end{inparaenum}
\item We construct a run-time monitoring algorithm for \csl{}, and
  validate the applicability of \csl{} by formalizing several contracts.
\end{itemize}

The rest of the paper is organized as follows. In section
\ref{sec:tracemodel} we present the abstract contract model, and
analyze contract compositonality. In section
\ref{sec:runtimemonitoring} we define abstractly what run-time
monitoring is. In section \ref{sec:csl} we present the contract
specification language \csl{}, together with a type system, and formal
semantics. In section \ref{sec:runtimemonitoringcsl} we construct an
incremental run-time monitoring algorithm for \csl{} contracts, and
prove that it defines a run-time monitor, as defined in section
\ref{sec:runtimemonitoring}, for (the denotation of) \csl{}
specifications. In section  \ref{sec:cslexamples} we present example
encodings in \csl{}. Finally, we conclude in section
\ref{sec:conclusion} with a perspective on future work and related
work.

\section{Trace-based contract model}\label{sec:tracemodel}
We strive to make our contract model as general as possible, and we
therefore parametrize the model over \emph{signatures}, instead of
fixing the model to for instance a business ontology. A signature can
be thought of as the \emph{vocabulary} used in a contract, and
formally it is a triple, $S =
(\actionkindset,\tp,\typeset)$, where $\actionkindset$ is a set of
\emph{action kinds}, with associated arities and types, $\tp :
\actionkindset \to \typeset^*$, and $\typeset$ is the set of all
types. An \emph{action} has the form $k(\vec{d})$, where $k \in
\actionkindset$, $\tp(k) = (\type_1,\ldots,\type_n)$, and $\vec{d} 
\in \dendom{\type_1} \times \cdots \times
\dendom{\type_n}$. ($\dendom{\type}$ denotes the domain of  type
$\type$, e.g., $\dendom{\mathrm{Int}} = \mathbb{Z}$.) $\actionset$
denotes the set of all actions (over signature $S$). Actions represent
that ``something happens'', but not who is responsible and when the
action takes place. Consequently, we introduce \emph{events}: an event
is a triple, $\event{t}{a}{k(\vec{d})}$, where $t \in \timeset$ is a
\emph{time stamp}, $a \in \agentset$ is the \emph{agent} responsible
for the action, and $k(\vec{d})$ is an action. $\agentset$ denotes the
(potentially infinite) set of all agents, i.e., potential contract
participants, and $\timeset = \nat$ denotes the time domain, with
standard ordering $\leq$. For a finite set of agents, $A \finsubset
\agentset$, $\eventset{A} = \timeset \times A \times \actionset$
denotes the set of events performable  by agents $A$.

As an example, we can define a signature for modeling payments: $S_p
= (\{\mathrm{payment}\}, \tp, \{\mathrm{USD},\mathrm{Agent}\})$, where
$\tp(\mathrm{payment}) = (\mathrm{USD},\mathrm{Agent})$,
$\dendom{\mathrm{USD}} = \mathbb{N}$, and $\dendom{\mathrm{Agent}} =
\agentset$. Then the event
$\event{1000}{a_1}{\mathrm{payment}(500,a_2)}$ represents the action
that agent $a_1$ pays 500 USD to agent $a_2$ at time $1000$. Note that
we will often write time stamps as dates rather than integers (e.g.,
2010-05-01), which can be interpreted as UNIX time (e.g.,
1,272,672,000). Note also that events are always associated with an
agent responsible for the action, which means that external events
such as  \emph{force majeure} will have to be modelled using an
explicit agent, i.e., \emph{nature}.

As mentioned in the introduction, the outcome of a contract is
determined by the events that take place. We therefore lift events to
\emph{event traces}, $\traceset{A} = \eventset{A}^{*}$, where we
require that all traces must have strictly increasing timestamps, in
order to guarantee a unique ordering of events. $\emptytrace \in \traceset{A}$ denotes the empty trace,
and $\sqsubseteq$ denotes the prefix order on $\traceset{A}$,
i.e.,
\[
\trace \sqsubseteq \trace' \mbox{ iff } \exists \trace'' \in
\traceset{A}. \trace ' = \trace \trace'' .
\]
For a trace, $\trace \in \traceset{A}$, $\tracestart(\trace),
\traceend(\trace) \in \timeset_\bot$ denote the time stamp of the
first, respectively last, event in $\trace$, and 
$\tracestart(\emptytrace) = \traceend(\emptytrace) =
\bot$. ($\timeset_\bot$ is the time domain $\timeset$ extended with a
least element $\bot$.) For $\trace \in \traceset{A}$ and $t \in
\timeset$, $\trace_t \in \traceset{A}$ denotes the trace that is the
largest prefix of $\trace$ with $\traceend(\trace_t) \leq t$, i.e.
\[
\trace_t \sqsubseteq \trace \land \traceend(\trace_t) \leq
t \land \left(\forall \trace' \in \traceset{A}. \trace_t \sqsubseteq \trace'
\sqsubseteq \trace \Rightarrow \trace' = \trace_t \lor
\traceend(\trace') > t \right).
\]

We now have a notion of traces, which represent complete histories of
what has happened. Intuitively then, a contract should partition
traces into those that are conforming, and those that are
nonconforming, which is the approach taken by for instance Andersen
et al. \cite{andersen06contracts} and Kyas et
al. \cite{kyas08clrm}. However, as mentioned in the introduction, it 
is crucial  that all contract violations be attributed to a nonempty 
subset of the parties involved in the contract --- we therefore
generalize the traditional 0/1 outcome: for $A \finsubset \agentset$,
the set of \emph{verdicts} is defined by:
\[
\verdictset{A} = \{(t,B) \mathbin{|} t \in \timeset,
\emptyset \neq B \subseteq A\} \cup \{\conforming\}.
\]
An execution can be conforming with
the contract, denoted $\conforming$, or the execution can be a
violation of the contract, in which case the violation is
associated with a set of agents and the time of violation, denoted
$(t,B)$. Contract conformance is not associated with a point
in time, whereas contract violations are; this is because conformance
with a contract might in some cases only take place ``at infinity'':
\begin{papercontract}
\item Agent $a$ is prohibited from performing action $k(\vec{d})$.
\end{papercontract}
In the example above, any violation will take place at the time where
$a$ actually performs the forbidden action, but contract conformance
is only guaranteed when we know that $a$ never performed the
action (i.e., at infinity). On the other hand, we require that all
violations be associated with a \emph{finite} point in time, which
means that contract violations cannot take place at infinity. This
restriction effectively means that we do not allow contracts to define
\emph{liveness properties} \cite{alpern84definingliveness}, e.g.
\begin{papercontract}
\item Agent $a$ must perform the action $k(\vec{d})$
  \emph{eventually}.
\end{papercontract}
But we see this as a natural restriction, since the main purpose of
formalizing contracts is to run-time monitor their execution, and
hence it only makes sense if contract violations can be detected in
finite time. We now have sufficient definitions to make the intuition
of a contract formal.
\begin{definition}[Contract]\label{def:contract}
  A contract involving agents $A \finsubset \agentset$ over the
  signature $S$, is a function, $\contract : \contractset{A}$, which
  must satisfy
  \begin{align}
    &\forall \trace \in \traceset{A}. \contract(\trace) = (t,B)
    \Rightarrow \left( \forall \trace' \in \traceset{A}. \trace_t =
      \trace'_t \Rightarrow \contract(\trace') = (t,B)\right).\label{def:contract1}
  \end{align}
  (All actions in the traces, $\trace \in \traceset{A}$, are required
  to be over the signature $S$.) $\contract(\trace) = \conforming$ means
  that $\trace$ is a conforming execution of $\contract$, and
  $\contract(\trace) = (t,B)$ means that $\trace$ is a nonconforming
  execution of $\contract$, and the violation took place at time $t$
  by agents $B$.
\end{definition}

The first thing we note about the definition is that contracts are
\emph{deterministic}, i.e., $\contract$ is a function and not in
general a relation, cf. the discusion in the introduction. We are
currently investigating an extension of the model to permit also
nondeterministic contracts, a discussion we will return to in section
\ref{sec:futurework}. We also note that contracts do not model  
situations where more breaches occur at different time points, which
is due to the view of fundamental breaches, also discussed in the
introduction. 

The next thing we note about the definition of contracts is that event
traces are considered \emph{complete} (or maximal), which means that
they represent a full history of what has happened (similar to the
idealized, infinite trace model of LTL \cite{huthryan04lics}). This
means that for instance the empty trace, $\emptytrace$, represents
that nothing has ever happened, and a trace, $\trace$, with
$\traceend(\trace) = t$ means that nothing ever happened after time
point $t$. The condition (\ref{def:contract1}) in the definition then
informally states that a contract violation at time $t$ can only
depend on what has (not) happened up until time $t$, i.e., it is a
sanity check that the verdict of  violation cannot depend on what
happens in the future. However, unlike the trace model of LTL, traces
are always \emph{finite}: the lemma below shows that this is no 
restriction, since the verdict on an infinite trace would be uniquely
determined by the verdict on all finite prefixes.
\begin{lemma}[Unique extension to infinite trace]
  Assume contracts are extended to include infinite traces, i.e.,
  $\contract: (\timeset \times A \times \actionset)^{\infty} \to
  \verdictset{A}$, where $X^\infty$ denotes the set of
  all finite and infinite traces over $X$. Then for an infinite trace,
  $\omega$, the following holds:
  \begin{align*}
    \contract(\omega) = (t,B) &\mbox{ iff } \exists \trace \in
    \traceset{A}. \trace \sqsubseteq \omega \land \tracestart(\omega
    \setminus \trace) > t \land \contract(\trace) = (t,B),
  \end{align*}
  where $\omega \setminus \trace$ represents the suffix of $\omega$ obtained
  by removing the finite prefix $\trace$.
\end{lemma}
\begin{proof}
  ``$\Rightarrow$'': If $\contract(\omega) = (t,B)$ then by
  (\ref{def:contract1}) it follows that $\contract(\omega_t) =
  (t,B)$. But then the result follows, as $\omega_t \sqsubseteq
  \omega$ and $\tracestart(\omega \setminus \omega_t) > t$. (Here we
  utilize that $\omega_t$ can only contain finitely many events, since
  time stamps are strictly increasing in event traces.) %which would be a
%  requirement for infinite traces, normally called \emph{progress}
%  \cite{alur94timedautomata}.)
  
  ``$\Leftarrow$'': Assume that $\contract(\trace) = (t,B)$, $\trace
  \sqsubseteq \omega$ and $\tracestart(\omega \setminus \trace) >
  t$. Then it follows that $\omega_t = \trace$, and consequently
  (\ref{def:contract1}) yields $\contract(\omega) = (t,B)$.
  \qed
\end{proof}

The lemma shows that a violation on an infinite trace is uniquely
determined by the existence of a finite prefix with the same
violation, provided that the finite prefix includes enough events from
the infinite trace. By contraposition, an infinite trace is conforming
exactly when no finite prefix is a violation, or the time of
violation is because not enough events are included. Hence the verdict
on an infinite trace will, due to (\ref{def:contract1}), be uniquely determined
by the verdicts on all finite prefixes, and consequently adding
infinite traces will not make the model more expressive. It follows as
a corollary that contract conformance defines a \emph{safety property}
\cite{alpern84definingliveness} (we have adopted Alpern and
Schneider's notion of safety to finite traces).
\begin{lemma}[Contract conformance is a safety property]
  Let $\contract$ be a contract involving agents $A$ over the
  signature $S$. Then the set $C = \{\trace \in \traceset{A} \mathbin{|}
  \contract(\trace) = \conforming \}$ defines a safety property, i.e.,
  $\forall \trace \not\in C. \exists \trace' \in \traceset{A}. \trace'
  \sqsubseteq \trace \land \forall \trace'' \in \traceset{A}. \trace'
  \sqsubseteq \trace'' \Rightarrow \trace'' \not\in C$.
\end{lemma}
\begin{proof}
  Assume $\trace \not\in C$, i.e., $\contract(\trace) = (t,B)$, for
  some $t$ and $B$. Now choose $\trace' = \trace_{t}$, and assume
  that $\trace' \sqsubseteq \trace''$: it then follows that $\trace''_t =
  \trace'_t = \trace_t$, and consequently (\ref{def:contract1}) guarantees that
  $\contract(\trace'') = (t,B)$, i.e., $\trace'' \not\in C$ as required.
  \qed
\end{proof}

Using the abstract definition of contracts, it is now
possible to define for instance a payment obligation (using the
payment signature $S_p$ from earlier) as follows:
\phantomsection\label{abstractexamplecontract}
\begin{align*}
\contract(\trace) = \left\{
  \begin{array}{ll}
    \conforming, &\mbox{if } \trace \mbox{ contains }
    \event{t}{\mathrm{Buyer}}{\mathrm{payment}(500,\mathrm{Seller})}\\
    & \hspace{18pt} \mbox{with } t \leq 1000\\
    (1000,\{\mathrm{Buyer}\}), &\mbox{otherwise}
  \end{array}
\right. .
\end{align*}
$\contract$ represents the obligation that Buyer has to pay 500 USD
to Seller on or before time 1000. (It is easy to check that the
function above satisfies the property (\ref{def:contract1}).)
However, writing contracts directly as abstract functions is clearly
not practical, so we therefore introduce a specification language in
section \ref{sec:csl}.

\subsection{Contract composition}\label{sec:contractcomposition}
We now consider how abstract contracts can be composed to define new
contracts, and how this affects blame assignment. We consider contract 
\emph{conjunction} and contract \emph{disjunction}, and as we shall
see, contract conjunction defines a deterministic contract, provided
that the sub contracts are deterministic, whereas this is in general
not the case for contract disjunction.

~

The intuition behind contract conjunction is to be able to combine the
commitments of two sub contracts --- typically, such sub contracts
are called clauses or paragraphs:
\begin{papercontract}
\item $a_1$ must pay $a_2$ 500 USD before or on 2010-06-01.
\item $a_2$ must deliver to $a_1$ 1 iPad before or on  2010-06-15.
\end{papercontract}
Assuming we have constructed sub verdicts for the two paragraphs,
$v_1$ and $v_2$, it is clear when the combined contract has been
fulfilled: exactly when the two sub contracts are fulfilled (i.e.,
$v_1 = v_2 = \conforming$). However, in case one (or both) sub
contracts are not fulfilled, we argued previously that the earlier
violation should be the combined verdict, i.e., in the case above
$a_1$ has violated the contract on 2010-06-01 if $a_1$ fails to
deliver as promised, even if $a_2$ does not pay. We therefore first define
how to take the conjunction of two verdicts.
\begin{definition}[Verdict conjunction]
  Let $v_1,v_2 \in \verdictset{A}$ be two verdicts. Then the
  conjunction, $v_1 \otimes v_2$, is defined by:
  \[
  v_1 \otimes v_2 = \left\{
    \begin{array}{ll}
      \conforming, &\mbox{ if } v_1 = v_2 = \conforming\\
      (t_1,B_1), & \mbox{ if } v_1 = (t_1,B_1) \land (v_2 =
      \conforming \lor (v_2 = (t_2,B_2) \land t_1 < t_2))\\
      (t_2,B_2), & \mbox{ if } v_2 = (t_2,B_2) \land (v_1 =
      \conforming \lor (v_1 = (t_1,B_1) \land t_2 < t_1))\\
      (t,B_1 \cup B_2), & \mbox{ if } v_1 = (t,B_1) \land v_2 = (t,B_2)
    \end{array}
  \right. .
  \]
\end{definition}

So it remains to define how to construct the sub verdicts, $v_1$ and
$v_2$, for sub contracts $\contract_1$ and $\contract_2$, given a
trace $\trace$. The immediate solution is $v_1 = \contract_1(\trace)$
and $v_2 = \contract_2(\trace)$, but the problem with this definition
is that events are treated \emph{nonlinearly}, so for instance the
contract
\begin{papercontract}
\item $a_1$ must pay $a_2$ 100 USD on or before 2010-06-01.
\item $a_1$ must pay $a_2$ 100 USD on or before 2010-06-15.
\end{papercontract}
will be fulfilled by the trace $\trace
=\event{\mbox{2010-06-01}}{a_1}{\mathrm{payment}(100,a_2)}$, even  
though the intention is that $a_1$ must pay 100 USD twice. (The
contract above may seem unrealistic, and probably no contract
\emph{starts} with two identical payments, but it may be that the
execution of a contract results in a state, where two identical
payments are expected.) We therefore need a way of partitioning the
trace $\trace$ into two parts: those events that belong to
$\contract_1$ and those that belong to $\contract_2$. So the question
is how to perform such splitting, and the approach we take is simple:
the agents generating the events should decide. For instance in the
example above, if $a_1$ pays 100 USD to $a_2$ on 2010-06-01, then
\emph{probably} $a_1$ would like the early payment to be discharged,
but we really cannot know. By making $a_1$ in charge of the explicit
choice, we avoid having to make potentially unintended choices in the
semantics of contract conjunction, and in fact this definition also
matches what often happens in real world contracts, where identical
payments are made distinguishable by assigning a unique reference
number to each payment.

Consequently, we extend events with a \emph{choice} parameter:
\renewcommand{\event}[4]{\langle #1, #2, #3, #4 \rangle}
$\eventset{A} = \timeset \times A \times \{l,r\}^* \times
\actionset$. A single event is written
$\event{t}{a}{\choice}{k(\vec{d})}$, and $l$ and $r$ denote
\emph{left} and \emph{right} choice, respectively. For a choice,
$\choice \in \{l,r\}^*$, $l.\choice$ (respectively $r.\choice$)
denotes the concatenation of $l$ (respectively $r$) to $\choice$, and
$\emptychoice$ denotes the empty choice sequence. Note that choices
are in general sequences, as there may be nested conjunctions. All our
previous definitions using events are redefined in the straightforward
way to events with explicit choice, so we omit these definitions. We
can now define contract conjunction:
\begin{definition}[Contract
  conjunction]\label{def:contractconjunction}
  Let $\contract_1$ and $\contract_2$ be two contracts involving
  agents $A$ over the signature $S$. The composition, $\contract_1
  \otimes \contract_2$, is defined by:
  \[
  (\contract_1 \otimes  \contract_2)(\trace) = 
  \contract_1(\trace_1) \otimes \contract_2(\trace_2),
 \]
  where $\tracesplit(\trace) = (\trace_1,\trace_2)$:
  \begin{align*}
    \tracesplit(\emptytrace) &= (\emptytrace,\emptytrace)\\
    \tracesplit(\event{t}{a}{l . \choice}{k(\vec{d})}\trace) &=
    (\event{t}{a}{\choice}{k(\vec{d})}\trace_1,\trace_2), \mbox{
      where } \tracesplit(\trace) = (\trace_1,\trace_2)\\
    \tracesplit(\event{t}{a}{r . \choice}{k(\vec{d})}\trace) &=
    (\trace_1,\event{t}{a}{\choice}{k(\vec{d})}\trace_2), \mbox{
      where } \tracesplit(\trace) = (\trace_1,\trace_2)\\
    \tracesplit(\event{t}{a}{\emptychoice}{k(\vec{d})}\trace) &=
    (\trace_1,\event{t}{a}{\emptychoice}{k(\vec{d})}\trace_2), \mbox{
      where } \tracesplit(\trace) = (\trace_1,\trace_2) .
  \end{align*}
\end{definition}

The $\tracesplit$ function partitions the events of a trace into
those that should go to the left conjunct, and those that should to
the right conjunct. If no explicit choice is made, we default to the
right conjunct, in order to avoid nondeterminism. (As mentioned above,
we are currently investigating a refined contract model which permits
nondeterminism, in which setting the empty choice will give rise to both
possibilities. With this interpretation, contract conjunction may be
nondeterministic, however the nondeterminism is only due to the lack
of information in the supplied events.)

\begin{lemma}[Contract conjunction is a contract]
  Let $\contract_1$ and $\contract_2$ be two contracts involving
  agents $A$ over the signature $S$. Then the composition,
  $\contract_1 \otimes \contract_2$, is a contract.
\end{lemma}
\begin{proof}
  It follows immediately that $\contract_1 \otimes \contract_2 :
  \contractset{A}$, and condition (\ref{def:contract1}) of Definition
  \ref{def:contract} follows by definition of $\otimes$ and the fact
  that $\contract_1$ and $\contract_2$ are contracts.
  \qed
\end{proof}

Due to the similarities with \emph{multiplicative conjunction} from
linear logic, we deliberately use the symbol $\otimes$, rather than
$\land$: what distinguishes contract conjunction from multiplicative
conjunction however, is the fact that each event specifies in which
conjunct it must be used (where as in linear logic, any splitting that
satisfies both conjuncts will do). A similar approach is taken by
Andersen et al. \cite{andersen06contracts} (called
event routing) and Japaridze describes this
phenomenon as playing two games in parallel
\cite{japaridze02logicofgames}, where the players ``name'' their moves
either $l$ (for game 1) or $r$ (for game 2).

~

As seen above, contract conjunction can be defined on general,
abstract contracts, and contract conjunction can be interpreted
as a deterministic operator. So the next question is if the same holds
for contract disjunction. We proceed as in the case of contract
conjunction, and assume we have constructed sub verdicts for the two
sub contracts, $v_1$ and $v_2$. As was the case for contract
conjunction, it is easy to define conformance: a disjunction is
fulfilled exactly when at least one of the two sub contracts are 
fulfilled (i.e., $v_1 = \conforming$ or $v_2 = \conforming$). Dually
to contract conjunction, if both sub contracts are violated, then the
combined verdict should be the \emph{last} violation, but if both
violations take place at the same point in time by different agents,
then we cannot combine the verdicts to a deterministic verdict: e.g.,
if $v_1 = (10,\{a\})$ and $v_2 = (10,\{b\})$, then the only sensible
conclusion is that \emph{either} $a$ has violated the contract at time
point 10, \emph{or} $b$ has violated the contract at time point 10,
which is not a deterministic verdict. This makes disjunction an
inherently nondeterministic operator, but since we only consider
deterministic contracts, verdict disjunction becomes a partial
operator.
\begin{definition}[Verdict disjunction]
  Let $v_1,v_2 \in \verdictset{A}$ be two verdicts. Then the
  disjunction, $v_1 \oplus v_2$, is  defined by:
  \[
  v_1 \oplus v_2 = \left\{
    \begin{array}{ll}
      v_1, &\mbox{ if } v_2 = \conforming \lor v_1 = v_2\\
      v_2, &\mbox{ if } v_1 = \conforming \lor v_1 = v_2\\
      (t_1,B_1), & \mbox{ if } v_1 = (t_1,B_1) \land v_2 = (t_2,B_2)
      \land t_1 > t_2\\
      (t_2,B_2), & \mbox{ if } v_1 = (t_1,B_1) \land v_2 = (t_2,B_2)
      \land t_1 < t_2\\
      \mbox{undefined}, & \mbox{ otherwise}
    \end{array}
  \right. .
  \]
\end{definition}

The definition matches the intuition explained above, and only in the
case where the two verdicts are violations at the same point in time
by different agents, is the disjunction undefined. Contract
disjunction can then be defined also as a partial operator (where
there is no need to partition the trace as for contract conjunction).
\begin{definition}[Contract disjunction]\label{def:contractdisjunction}
  Let $\contract_1$ and $\contract_2$ be two contracts involving
  agents $A$ over the signature $S$. The composition, $\contract_1
  \oplus \contract_2$, is defined by:
  \[
  (\contract_1 \oplus  \contract_2)(\trace) =
  \contract_1(\trace) \oplus \contract_2(\trace),
  \]
  where $\contract_1 \oplus \contract_2$ is only defined when
  $\contract_1(\trace) \oplus \contract_2(\trace)$ is defined, for all
  $\trace \in \traceset{A}$.
\end{definition}

By definition, contract disjunction can be undefined, but if we
restrict disjunction to the case where it is a choice by one agent, it
becomes well-defined, because in that case only one agent can be
blamed. This means that contract disjunction can be used to
encode contrary-to-duty obligations:
\begin{papercontract}
\item $a_1$ must pay $a_2$ 100 USD on or before 2010-06-01.
\item If $a_1$ fails to pay the above before the deadline, $a_1$ must
  pay $a_2$ 110 USD on or before 2010-06-15.
\end{papercontract}
In the example above, if $a_1$ does not pay on the early nor the late
deadline, then the combined verdict, $(\mbox{2010-06-01},\{a_1\})
\oplus (\mbox{2010-06-15},\{a_1\})$, is a violation at the time of the 
late deadline, $(\mbox{2010-06-15},\{a_1\})$.

\begin{lemma}[Contract disjunction is a contract]
  Let $\contract_1$ and $\contract_2$ be two contracts involving
  agents $A$ over the signature $S$. Then the composition,
  $\contract_1 \oplus \contract_2$, is a contract, provided that it is
  defined.
\end{lemma}
\begin{proof}
  It follows immediately that $\contract_1 \oplus \contract_2 :
  \contractset{A}$, and condition (\ref{def:contract1}) of Definition
  \ref{def:contract} follows by definition of $\oplus$ and the fact
  that $\contract_1$ and $\contract_2$ are contracts.
  \qed
\end{proof}

\begin{proposition}[Contract equivalences]
  Consider three contracts, $\contract_1$, $\contract_2$, and
  $\contract_3$ involving agents $A$ over the signature $S$. Then the
  following hold:
  \begin{align*}
    \contract_1 \otimes \contract_2 &\equiv \contract_2 \otimes
    \contract_1\\
    \contract_1 \oplus \contract_2 &= \contract_2 \oplus
    \contract_1\\
    \contract_1 \otimes (\contract_2 \otimes \contract_3) &\equiv
    (\contract_1 \otimes \contract_2) \otimes \contract_3\\
    \contract_1 \oplus (\contract_2 \oplus \contract_3) &=
    (\contract_1 \oplus \contract_2) \oplus \contract_3\\
    \contract_1 \otimes (\contract_2 \oplus \contract_3) &=
    (\contract_1 \otimes \contract_2) \oplus (\contract_1 \otimes
    \contract_3)\\
    \contract_1 \oplus (\contract_2 \otimes \contract_3) &\equiv
    (\contract_1 \oplus \contract_2) \otimes (\contract_1 \oplus
    \contract_3) ,
  \end{align*}
  where $\equiv$ means equality modulo choices.
\end{proposition}
\begin{proof}
  Follows immediately from the corresponding rules for verdict
  conjunction and verdict disjunction, which are easily seen to hold.
  \qed
\end{proof}

\section{Run-time monitoring}\label{sec:runtimemonitoring}
We argued in the introduction of this paper that run-time monitoring
of contracts is crucial. In this section we define abstractly what a
run-time monitor is, using a many-valued semantics as is conventional 
in run-time monitoring \cite{leucker09rv}. In the abstract contract model, traces
are assumed to be complete, in the sense that the finite traces
describe all that has happened (and ever will happen). For run-time
monitoring however, traces are necessarily never complete, as events
may be generated continuously. Therefore, even though both the
abstract trace model and the run-time monitor deal with finite
traces, we consider them to be semantically different.
\begin{definition}[Run-time monitor]
  Let $\contract$ be a contract involving agents $A$ over the
  signature $S$. A run-time monitor for $\contract$ is a function,
  \[
  \rmf_\contract : \{ (\trace,t) \in \traceset{A} \times
  \timeset \mathbin{|} \traceend(\trace) \leq t \} \to
  \verdictset{A} \cup \{\conforming, \partialok, \inconclusive\},
 \]
  which must satisfy
  \[
  \rmf_\contract(\trace,t) = \left\{
    \begin{array}{ll}
      \conforming, & \mbox{ if } \forall \trace' \in
      \traceset{A}. \trace'_t = \trace \Rightarrow \contract(\trace') =
      \conforming\\
      \partialok, & \mbox{ if } \exists \trace' \in
      \traceset{A}. \trace'_t = \trace \land \contract(\trace') \neq
      \conforming \land \contract(\trace) = \conforming\\ 
      (t',B), & \mbox{ if } \contract(\trace) = (t',B) \land t' \leq t\\
      \inconclusive, & \mbox{ otherwise}
    \end{array} .
  \right.
  \]
\end{definition}

The verdict of a run-time monitor should be interpreted as follows:
\begin{inparaenum}[(i)]
\item if $\rmf_\contract(\trace,t) = \conforming$, then nobody will violate
  the contract, no matter what happens in the future;
\item if $\rmf_\contract(\trace,t) = \partialok$, then nobody will violate the
  contract, provided that nothing happens in the future;
\item if $\rmf_\contract(\trace,t) = (t',B)$ then the contract has been
  violated by agents $B$ at time $t' \leq t$; and
\item if $\rmf_\contract(\trace,t) = \inconclusive$ then we cannot yet
  say who (if any) have violated the contract.
\end{inparaenum}

Most interestingly, run-time monitoring is not defined on partial
traces only, but instead on partial traces and a \emph{current
  point in time}, which is therefore required to be at least the time
of the last event in the partial trace, cf. the type of
$\rmf_\contract$. This is because contracts may be violated due to
some deadline not being met, in which case a violation should be
reported. If we consider the contract $\contract$ from
page \pageref{abstractexamplecontract}, then a violation should be
reported if nothing happens for the first 1000 time units, since in
that case we know Buyer has failed to pay Seller; and indeed by
definition $\rmf_\contract(\emptytrace,1000) =
\{(1000,\{\mathrm{Buyer}\})\}$. But had we instead defined
$\rmf_\contract$ only on partial traces, then the run-time monitor
could only report a violation once some (random) event took place
after time point 1000 --- and such event might never happen, or
perhaps only after years. Note also that the condition
(\ref{def:contract1}) of Definition \ref{def:contract} ensures that if
a run-time monitor outputs a violation, $(t',B)$, then the violation
is definite, i.e., it cannot be changed by what might happen in the
future (assuming what happens in the future is after the
\emph{current point in time} parameter).

It is worth mentioning that the abstract definition of run-time
monitoring satisfies the \emph{impartiality} maxim \cite{leucker09rv},
i.e., for all $\trace,\trace' \in \traceset{A}$ with $\trace =
\trace'_t$, we have that $\rmf_\contract(\trace,t) = \conforming
\Rightarrow \rmf_\contract(\trace',t') = \conforming$, for all $t'
\geq \traceend(\trace')$, and $\rmf_\contract(\trace,t) = (t'',B)
\Rightarrow \rmf_\contract(\trace',t') = (t'',B)$, for all $t' \geq
\traceend(\trace')$. However, the \emph{anticipation} maxim 
\cite{leucker09rv} is not satisfied, since inevitable future
violations are not reported until the future has been reached.

\section{A contract specification language}\label{sec:csl}
In this section we present the contract specification language \csl{},
which by construction can be mapped into the abstract, trace-based
model presented in the previous section. \csl{} is inspired by the
language of Andersen et al. \cite{andersen06contracts}, but there are
some major differences, the most important of which are:
\begin{itemize}
\item \csl{} uses the trace model from the previous section, hence all
  contracts encoded in \csl{} have deterministic blame assignment.
\item \csl{} is parametrized over signatures, so is not fixed to a
  particular contract domain.
\item \csl{} permits internal conditionals, atomic obligations, and
  atomic permissions.
\item \csl{} prohibits nondeterministic choice, general sequencing, and
  explicit failure.
\item \csl{} statically infers the agents involved in a contract via
  type checking.
\item \csl{} avoids potential deadlines in the past.
\end{itemize}

The full grammar for \csl{} is presented in Figure \ref{fig:cslsyntax},
and we describe the intuitive meaning of each construct below.
\begin{figure}[b!]
  \begin{center}
    \begin{bnf}
      p &::= & \ccontract{\{\cinstantiate{f_i}{\vec{x_i}}{\vec{y_i}} =
        c_i\}_{i = 1}^n}{c}{t} & (\csl{} contract)\\
      \\
      c &::= & \cempty & (No obligations nor rights)\\
      & \bnfsep & \mathit{ac} & (Atomic clause)\\
      & \bnfsep & \canddefault & (Conjunction)\\
      & \bnfsep & \cordefault & (Disjunction)\\
      & \bnfsep & \cifthenelsedefault & (Conditional)\\
      & \bnfsep & \cinstantiatedefault & (Template instantiation)\\
      \\
      \mathit{ac} &::=& \catomic{e_a}{k(\vec{x})}{x}{e}{e_d}{c} & (Atomic
      obligation)\\
      &\bnfsep&
      \catomicp{\vec{e_a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2} & (Atomic
      permission)\\
      \\
      e &::=& x \bnfsep d \bnfsep e \textsf{D} \bnfsep e \textsf{W}
      \bnfsep e_1 \circ e_2 \bnfsep e_1 \prec e_2 & (Expressions)\\
      e_a &::=& x \bnfsep a & (Agent expressions)\\
      e_d &::=& \cwithinafter{e_1}{e_2}
      & (Deadline expressions)\\
      \circ &\in & \{+, -, *, /,\mathbin{--},\candalso \}\\
      \prec &\in & \{<, \leq, =\}
    \end{bnf}
  \end{center}
  \caption{The grammar of \csl{}. $f \in \templatenameset$ ranges over
    template names, $x,y \in \varset$ range over variables, $t \in
    \timeset$ ranges over time values, $k \in \actionkindset$ ranges
    over action kinds, $a \in \agentset$ ranges over agents, and $d$
    ranges over base values (e.g., integers).}
  \label{fig:cslsyntax}
\end{figure}
A \csl{} contract, $p$, consists of a set of mutually recursive
template definitions, which can be referenced in the body of the
contract. The body of a \csl{} contract constitutes a \emph{clause},
$c$, together with an absolute point in time, which defines the
starting point of the contract. The parameters of a template are
divided into values, $\vec{x}$, and agents, $\vec{y}$. Value
parameters are \emph{dynamic}, meaning that they can be initialized
with actual values from earlier events, whereas agent parameters
are \emph{static}, meaning that all contract agents are defined in the 
top-level body of the \csl{} contract, and the participants do not
change over time. Mutual recursion makes it possible to define
potentially infinite contract in \csl{}, and we provide an example of
such contract in section \ref{sec:cslexamples}.

Clauses, $c$, can be thought of as \emph{pre contracts}, in the sense
that they describe the normative content of a contract, but all
deadlines in clauses are defined using relative measures such as ``4
days''. The relative deadlines are lifted to absolute deadlines when
the clause is used in a \csl{} contract context, thereby lifting the
pre contract to a contract. The language 
of clauses does not include deontic modalities directly, but instead uses
a closed-world assumption: all actions that are obliged are
automatically permitted, and all actions that are not explicitly
permitted are automatically prohibited.

$\cempty$ is the simplest clause. It represents a trivially
fulfilled clause, in which nothing is obliged nor permitted, and hence 
all actions are prohibited. Atomic clauses are divided into atomic
\emph{obligations} and atomic \emph{permissions}. Instantiated atomic
obligations have the form
\[
\catomic{a}{k(\vec{x})}{x}{e}{e_d}{c},
\]
which should be read: ``$a$ \emph{must} perform an action of kind $k$,
which satisfies the condition $e$ and the deadline $e_d$. After
successful completion, $c$ is the residual clause''. As mentioned
above, deadlines are always relative: the reason we do not allow
absolute deadlines such as 1st of May 2010 directly in clauses, is to
avoid deadlines in the past, e.g., ``first $a_1$ must pay on
2010-05-01, and then $a_2$ must deliver on 2010-04-01''. Deadline
expressions, $e_d$, always evaluate to an interval, and in order to
make sure that the interval is nonempty, the upper bound is relative
to the lower bound, e.g., $e_d \equiv \cwithinafter{10}{100}$ means
that $a$ is obliged to perform the $k$-action within 10 time units
\emph{after} 100 time units have passed (corresponding to the interval
$[100;110]$). In order to easier specify deadlines, the expression
language contains day and week operators, $e\textsf{D}$ and
$e\textsf{W}$ respectively, so for instance $e_d \equiv
\cwithinafter{1\textsf{W}}{1\textsf{D}}$ corresponds to the interval
$[1*24*60*60;8*7*24*60*60]$.
The vector of variables, $\vec{x}$, is bound to 
the actual $k$-values in the event, and $x$ is bound to the relative
time elapsed until the event is performed, i.e., \textsf{@} can be
thought of as a relative freeze quantifier \cite{alur94tptl}. The
scope of $\vec{x}$ is $e$ and $c$, while the scope of $x$ is $c$
only. All deadlines in the continuation, $c$, are relative to the time
of the $k$-event.

Instantiated atomic permissions have the form
\[
\catomicp{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2},
\]
which should be read: ``any agent $a \in \vec{a}$ \emph{may} perform
an action of kind $k$, which satisfies the condition $e$ and 
the deadline $e_d$, after which $c_1$ is the residual clause. If the
action is not performed within the deadline, $c_2$ is the residual
clause''. Contrary to atomic obligations, atomic permissions can in
general include a nonempty set of agents, which is possible because
an atomic permission cannot be violated by not performing it (in that
case $c_2$ dictates the further commitments). As for atomic
obligations, deadlines are relative, and the scope of $\vec{x}$ is $e$
and $c_1$, while the scope of $x$ is $c_1$ only. All deadlines in $c_1$ are 
relative to the time of the permitted event, and all deadlines in
$c_2$ are relative to the point in time where the deadline of the atomic
permission is expired.

$\canddefault$ and $\cordefault$ denote clause conjunction
and disjunction, respectively, which we already described in Section
\ref{sec:contractcomposition}. The type system of \csl{}, which
we present in the following section, ensures that $c_1$ and $c_2$ only
stipulate commitments on the same agent in clause disjunctions,
which, as we shall see, is sufficient to guarantee that the semantic
disjunction, $\oplus$, is always defined. $\cifthenelsedefault$ represents
(internal) clause branching, where 
the branching condition $e$ can be computed directly without
having to wait for external input (i.e., events), and finally
$\cinstantiatedefault$ denotes instantiation of template $f$,
where $\vec{e}$ are clause parameters, and $\vec{e_a}$ 
are agent parameters. As mentioned earlier, $\vec{e}$ may refer to
values from previous events, whereas $\vec{e_a}$ cannot. The scope of
the $\vec{e}$ values inside the body of the template is restricted to
(deadline) expressions, whereas the scope of the $\vec{e_a}$ values is
both (deadline) expressions and agent expressions.

When we specify contracts in \csl{}, we will use the following
syntactic conventions: $\cimmediately \equiv \cwithinafter{0}{0}$,
$\cimmediatelyafter{e} \equiv \cwithinafter{0}{e}$, $\cwithin{e}
\equiv \cwithinafter{e}{0}$, and omitting the continuation clause in
atomic clauses implicitly means $\cempty$, e.g.
\[
\langle e_a \rangle\ k(\vec{x})\ \textsf{@}\ x\
\mathsf{where}\ e\ \mathsf{due}\ e_d \equiv
\catomic{e_a}{k(\vec{x})}{x}{e}{e_d}{\cempty}.
\]
Furthermore, we will often omit the freeze variable from atomic
clauses, when it is not used.
Before presenting the type system and semantics of \csl{}, we show how
the contract in Figure \ref{fig:salescontract} can be formalized in \csl{}.
\begin{figure}[t]
  \begin{papercontract}
  \item Seller agrees to transfer and deliver to Buyer,
    on or before 2010-06-01, the goods: 1 iPad.
  \item Buyer agrees to accept the goods and pay a total
    of 500 USD for them according to the terms further
    set out below.
  \item Buyer agrees to pay for the goods half upon
    receipt, with the remainder due within 30 days of
    delivery.
  \item If Buyer fails to pay the second half within
    30 days, an additional fine of 10\% has to be paid within 14
    days. \label{clausectd}
  \item Upon receipt, Buyer has 14 days to examine the goods and claim
    for damages in case the goods are broken. 7 days after a
    claim for damages, Seller has to repay 500 USD to
    Buyer. \label{clauseclaim}
  \end{papercontract}
  \caption{Sales contract.}\label{fig:salescontract}
\end{figure}
The encoding below defines \texttt{sale} as a clause template, which
is instantiated in the body of the \csl{} contract. The encoding
assumes a signature with TransferAndDeliver, Payment, ClaimForDamages
$\in \actionkindset$:
\phantomsection\label{csl:salescontract}
\begin{lstlisting}[language=csl]
letrec
sale(deliveryDeadline, goods, amount)<buyer, seller> =
 // First seller must deliver goods
 <seller> TransferAndDeliver(g,r)
  where g == goods andalso
        r == buyer
  due within deliveryDeadline
  then
    // Buyer must pay half upon receipt
    <buyer> Payment(a,r)
     where a == amount / 2 andalso
           r == seller
     due immediately
     then
       ((// Remainder due within 30 days of receipt
         <buyer> Payment(a,r)
          where a == amount / 2 andalso
                r == seller
          due within 30D
         or
         // Fine in case of late payment
         <buyer> Payment(a,r)
          where a == 1.1 * (amount / 2) andalso
                r == seller
          due within 14D after 30D)
        and
        // Buyer has 14 days to claim for damages
        if <buyer> ClaimForDamages(g,r)
            where g == goods andalso
                  r == seller
            due within 14D
        then
          // In case the goods are damaged, Seller must repay Buyer
          <seller> Payment(a,r)
           where a == amount andalso
                 r == buyer
           due within 7D)
in
sale(0D, "iPad", 500)<Tom, Apple> starting 2010-06-01
\end{lstlisting}
The rather small example illustrates conditional commitments (Seller's
obligation to repay Buyer in case of damaged goods), relative and
absolute temporal constraints (immediate payment after delivery and
delivery at a specific date, respectively), contrary-to-duty
obligations (fine in case of late payment), and arithmetic expressions
(calculation of fine).

\subsection{Type system}
\newcommand{\ctpduration}{\mathrm{Duration}}
\newcommand{\ctpbool}{\mathrm{Bool}}
\newcommand{\ctpnat}{\mathrm{Nat}}
\newcommand{\ctpint}{\mathrm{Int}}
\newcommand{\ctpagent}{\mathrm{Agent}}
\newcommand{\ctpdeadline}{\mathrm{Deadline}}
\newcommand{\ctpclause}[1]{\mathrm{Clause} \langle #1 \rangle}
\newcommand{\ctpatomic}[1]{\mathrm{Atomic} \langle #1 \rangle}
\newcommand{\ctpcontract}[1]{\mathrm{Contract} \langle #1 \rangle}
\newcommand{\ctaexp}[3]{#1 \vdash #2 : #3}
\newcommand{\ctdexp}[2]{#1 \vdash #2 : \ctpdeadline}
\newcommand{\ctexp}[3]{#1 \vdash #2 : #3}
\newcommand{\ctclause}[5]{#1,#2,#3 \vdash #4 : \ctpclause{#5}}
\newcommand{\ctcontext}[2]{\vdash #1 : #2}
\newcommand{\ctcontract}[2]{\vdash #1 : \ctpcontract{#2}}
\newcommand{\ctcontractrec}[4]{\ctcontract{\ccontract{#1}{#2}{#3}}{#4}}

We now define a type system for \csl{}. The typing judgments are
defined with respect to  a signature, $S =
(\actionkindset,\tp,\typeset)$, and the following typing environments
are used:
\begin{align}
\Lambda &\subseteq \varset \tag{Agent typing environment}\\
\Gamma &: \varset \rightharpoonup \typeset \tag{Variable typing environment}\\
\Delta &: \templatenameset \rightharpoonup \typeset^* \times \nat
\tag{Template typing environment}
\end{align}
$\Lambda$ is an agent environment (i.e., typing environment for agent
variables); $\Gamma$ is the typing environment for ordinary variables;
and $\Delta$ is the typing environment for clause templates, which
associates with each template name the types of its parameters, and
the number of agent parameters. In general, for a partial function, $f
: A \rightharpoonup B$, and elements, $a \in A$, $b \in B$, we denote
by $f[a \mapsto b] : A \rightharpoonup B$ the partial function which
maps $a$ to $b$ and behaves like $f$ on all other input, $\emptyset$
denotes the partial function which is undefined for all elements in
the domain, and we abuse notation by writing $f[\vec{a} \mapsto
\vec{b}]$ for $f[a_1 \mapsto b_1]\cdots[a_n \mapsto b_n]$, where
$\vec{a} = (a_1,\ldots,a_n)$ and $\vec{b} = (b_1,\ldots,b_n)$.

The first typing judgments are for expressions, agent expressions, and
deadline expressions, respectively (Figure \ref{fig:ctexp}). We omit
the typing rules for constants, but assume $d : \type$, for each
$\type \in \typeset$ and $d \in \dendom{\type}$.
\begin{figure}[t]
  \fbox{$\ctexp{\Gamma}{e}{\type}$}
  \vspace{-23pt}
  \begin{center}
    \AxiomC{$x \in \dom{\Gamma}$}
    \UnaryInfC{$\ctexp{\Gamma}{x}{\Gamma(x)}$}
    \DisplayProof{}
    \quad\quad
    \AxiomC{$\ctexp{\Gamma}{e}{\ctpnat}$}\RightLabel{($i \in
      \{\textsf{D}, \textsf{W}\}$)}
    \UnaryInfC{$\ctexp{\Gamma}{e\ i}{\ctpduration}$}
    \DisplayProof{}

    \proofsep

    \AxiomC{$\ctexp{\Gamma}{e_1}{\ctpduration}$}
    \AxiomC{$\ctexp{\Gamma}{e_2}{\ctpduration}$}\RightLabel{($\circ \in
      \{+,\mathbin{--}\}$)}
    \BinaryInfC{$\ctexp{\Gamma}{e_1 \circ e_2}{\ctpduration}$}
    \DisplayProof{}

    \proofsep

    \AxiomC{$\ctexp{\Gamma}{e_1}{\ctpint}$}
    \AxiomC{$\ctexp{\Gamma}{e_2}{\ctpint}$}\RightLabel{($\circ \in
      \{+,-,*,/\}$)}
    \BinaryInfC{$\ctexp{\Gamma}{e_1 \circ e_2}{\ctpint}$}
    \DisplayProof{}

    \proofsep

    \AxiomC{$\ctexp{\Gamma}{e_1}{\ctpbool}$}
    \AxiomC{$\ctexp{\Gamma}{e_2}{\ctpbool}$}
    \BinaryInfC{$\ctexp{\Gamma}{e_1 \mathbin{\candalso}
        e_2}{\ctpbool}$}
    \DisplayProof{}

    \proofsep

    \AxiomC{$\ctexp{\Gamma}{e_1}{\type_1}$}
    \AxiomC{$\ctexp{\Gamma}{e_2}{\type_1}$}\RightLabel{($\prec \in
      \{<,\leq,=\}, \type_1,\type_2 \in \{\ctpnat, \ctpint\}$)}
    \BinaryInfC{$\ctexp{\Gamma}{e_1 \prec e_2}{\ctpbool}$}
    \DisplayProof{}
  \end{center}
  \fbox{$\ctaexp{\Lambda}{e_a}{A}$}
  \vspace{-23pt}
  \begin{center}
    \AxiomC{}
    \UnaryInfC{$\ctaexp{\emptyset}{a}{\{a\}}$}
    \DisplayProof{}
    \quad\quad
    \AxiomC{}
    \UnaryInfC{$\ctaexp{\{x\}}{x}{\emptyset}$}
    \DisplayProof{}
  \end{center}
  \fbox{$\ctaexp{\Lambda}{\vec{e_a}}{A}$}
  \vspace{-23pt}
  \begin{center}
    \AxiomC{$\ctaexp{\Lambda}{e_a}{A}$}
    \UnaryInfC{$\ctaexp{\Lambda}{(e_a)}{A}$}
    \DisplayProof{}
    \quad
    \AxiomC{$\ctaexp{\Lambda}{e_{a_1}}{A}$}
    \AxiomC{$\ctaexp{\Lambda'}{(e_{a_2},\ldots,e_{a_n})}{A'}$}
    \BinaryInfC{$\ctaexp{\Lambda \cup
        \Lambda'}{(e_{a_1},\ldots,e_{a_n})}{A \cup A'}$}
    \DisplayProof{}
  \end{center}
  \fbox{$\ctdexp{\Gamma}{e_d}$}
  \vspace{-23pt}
  \begin{center}
    \AxiomC{$\ctexp{\Gamma}{e_1}{\ctpduration}$}
    \AxiomC{$\ctexp{\Gamma}{e_2}{\ctpduration}$}
    \BinaryInfC{$\ctdexp{\Gamma}{\cwithinafter{e_1}{e_2}}$}
    \DisplayProof{}
  \end{center}
  \caption{Typing of expressions, agent expressions, and deadline expressions.}
  \label{fig:ctexp}
\end{figure}
Expressions of type $\ctpduration$ can be added and subtracted, but
subtraction uses the ``$--$'' operator (\emph{monus}) in order to
ensure that $\ctpduration$ values are always nonnegative. This
restriction is in order to guarantee that the deadline defined in a
deadline expression is never in the past.
The typing judgment for agent expressions uses \emph{relevance typing}
\cite{pierce04attpl}, meaning that all variables defined in the agent
typing environment are used \emph{at least once}. Typing of agent
expressions is lifted to vectors of agent expressions, where relevance
typing is also used.

The typing rules for clauses, template definitions, and full \csl{}
contracts are presented in Figure \ref{fig:ctclausecontract}.
\begin{figure}
  \fbox{$\ctclause{\Delta}{\Lambda}{\Gamma}{c}{A}$}
  \begin{center}
    \AxiomC{}
    \UnaryInfC{$\ctclause{\Delta}{\emptyset}{\Gamma}{\cempty}{\emptyset}$}
    \DisplayProof{}
   
    \proofsep{}

    \AxiomC{$\begin{array}{c}
        \tp(k) = (\type_1,\ldots,\type_n)\\
        \Gamma' = \Gamma[x_1 \mapsto \type_1, \ldots, x_n
        \mapsto \type_n]\\
        \Gamma'' = \Gamma'[x \mapsto \ctpduration]
      \end{array}$}
    \AxiomC{\hspace{-5pt}$\begin{array}{c}
        \ctaexp{\Lambda}{e_a}{A}\\
        \ctexp{\Gamma'}{e}{\ctpbool}\\
        \ctdexp{\Gamma}{e_d}
      \end{array}$}
    \AxiomC{\hspace{-5pt}$\begin{array}{c}
        \\\\
        \ctclause{\Delta}{\Lambda'}{\Gamma''}{c}{A'}
      \end{array}$}
    \TrinaryInfC{$\ctclause
      {\Delta}{\Lambda \cup
        \Lambda'}{\Gamma}{\catomic{e_a}{k(x_1,\ldots,x_n)}{x}{e}{e_d}{c}}{A \cup A'}$}
    \DisplayProof{}

    \proofsep{}

    \AxiomC{$\begin{array}{c}
        \tp(k) = (\type_1,\ldots,\type_n)\\
        \Gamma' = \Gamma[x_1 \mapsto \type_1, \ldots, x_n
        \mapsto \type_n]\\
        \Gamma'' = \Gamma'[x \mapsto \ctpduration]
      \end{array}$}
    \AxiomC{\hspace{-7.2pt}$\begin{array}{c}
        \ctaexp{\Lambda}{\vec{e_a}}{A}\\
        \ctexp{\Gamma'}{e}{\ctpbool}\\
        \ctdexp{\Gamma}{e_d}
      \end{array}$}
    \AxiomC{\hspace{-7.2pt}$\begin{array}{c}
        \\
        \ctclause{\Delta}{\Lambda_1}{\Gamma''}{c_1}{A_1}\\
        \ctclause{\Delta}{\Lambda_2}{\Gamma}{c_2}{A_2}
     \end{array}$}
    \TrinaryInfC{$\ctclause
      {\Delta}{\Lambda \cup
        \Lambda_1 \cup \Lambda_2}{\Gamma}{\begin{array}{c}\catomicp{\vec{e_a}}{k(x_1,\ldots,x_n)}{x}{e}{e_d\\}{c_1}{c_2}\end{array}}{A
        \cup A_1 \cup A_2}$}
    \DisplayProof{}

    \proofsep{}
    
    \AxiomC{$\ctclause{\Delta}{\Lambda_1}{\Gamma}{c_1}{A_1}$}
    \AxiomC{$\ctclause{\Delta}{\Lambda_2}{\Gamma}{c_2}{A_2}$}
    \BinaryInfC{$\ctclause{\Delta}{\Lambda_1 \cup
        \Lambda_2}{\Gamma}{\canddefault}{A_1 \cup A_2}$}
    \DisplayProof{}
    
    \proofsep{}

    \AxiomC{$|\Lambda| + |A| = 1$}
    \AxiomC{$\ctclause{\Delta}{\Lambda}{\Gamma}{c_1}{A}$}
    \AxiomC{$\ctclause{\Delta}{\Lambda}{\Gamma}{c_2}{A}$}
    \TrinaryInfC{$\ctclause{\Delta}{\Lambda}{\Gamma}{\cordefault}{A}$}
    \DisplayProof{}
    
    \proofsep{}

    \AxiomC{$\ctexp{\Gamma}{e}{\ctpbool}$}
    \AxiomC{$\ctclause{\Delta}{\Lambda_1}{\Gamma}{c_1}{A_1}$}
    \AxiomC{$\ctclause{\Delta}{\Lambda_2}{\Gamma}{c_2}{A_2}$}
    \TrinaryInfC{$\ctclause{\Delta}{\Lambda_1 \cup
        \Lambda_2}{\Gamma}{\cifthenelsedefault}{A_1 \cup A_2}$}
    \DisplayProof{}

    \proofsep{}
    
    \AxiomC{$\Delta(f) = ((\type_1,\ldots,\type_m),n)$}
    \AxiomC{$\ctaexp{\Lambda}{(e_{a_1},\ldots,e_{a_n})}{A}$}
    \AxiomC{$\forall i \in \{1,\ldots,m\}. \ctexp{\Gamma}{e_i}{\type_i}$}
    \TrinaryInfC{$\ctclause{\Delta}{\Lambda}{\Gamma}{\cinstantiate{f}{e_1,\ldots,e_m}{e_{a_1},\ldots,e_{a_n}}}{A}$}
    \DisplayProof{}
  \end{center}

  \proofsep{}

  \fbox{$\ctcontext{D}{\Delta}$}
  \begin{center}
    \AxiomC{$\begin{array}{c}
        \dom{\Delta} = \{f_1,\ldots,f_n\}\\
        \Delta(f_i) = ((\type_{i_1}, \ldots, \type_{i_{m_i}}), k_i)\\
        \Lambda_i = \{y_{i_1},\ldots,y_{i_{k_i}}\}\\
        \Gamma_i = \left[ \begin{array}{c}
            x_{i_1} \mapsto \type_{i_1},\ldots,x_{i_{m_i}} \mapsto
            \type_{i_{m_i}},\\
            y_{i_1} \mapsto \ctpagent, \ldots, y_{i_{k_i}} \mapsto
            \ctpagent
          \end{array} \right]
      \end{array}$}
    \AxiomC{\hspace{-12pt}$\begin{array}{c}
        \\\\\\\\
        \forall i \in
        \{1,\ldots,n\}. \ctclause{\Delta}{\Lambda_i}{\Gamma_i}{c_i}{\emptyset}
      \end{array}$}
    \BinaryInfC{$\ctcontext{\{\cinstantiate{f_i}{x_{i_1},\ldots,x_{i_{m_i}}}{y_{i_1},\ldots,y_{i_{k_i}}} =
        c_i\}_{i = 1}^n}{\Delta}$}
    \DisplayProof{}
  \end{center}

  \proofsep{}

  \fbox{$\ctcontract{p}{A}$}
  \begin{center}
    \AxiomC{$\ctcontext{D}{\Delta}$}
    \AxiomC{$\ctclause{\Delta}{\emptyset}{\emptyset}{c}{A}$}
    \BinaryInfC{$\ctcontractrec{D}{c}{t}{A}$}
    \DisplayProof{}
  \end{center}
  \caption{Typing of \csl{} clauses, template definitions, and contracts.}
  \label{fig:ctclausecontract}
\end{figure}
A derivation, $\ctclause{\Delta}{\Lambda}{\Gamma}{c}{A}$, means that
in template environment $\Delta$ and variable environment $\Gamma$,
$c$ is a well-typed clause involving \emph{exactly} agents
$A$ and parametrized agents $\Lambda$. Relevance typing of agent
expressions is utilized in the typing rule for clause disjunctions,
$\cordefault$, where the rule guarantees that each disjunct involves
the exact same (parametrized) agent, as mentioned earlier. The typing
judgment for template definitions, $\ctcontext{D}{\Delta}$, contains a
single rule, which requires that the body of a template definition not
contain ``hard coded'' agents --- this restriction is to make sure
that all agents are passed as parameters. Note also that the scope of
agent parameters is both (deadline) expressions and agent expressions,
i.e., the agent parameters are included in both the  general typing
environment, $\Gamma$, and the agent typing environment,
$\Lambda$. The final judgment, $\ctcontract{p}{A}$, is for full \csl{}
contracts, which collects the typing judgments for template
definitions and clauses.

\subsection{Denotational Trace Semantics}\label{sec:denotation}
\newcommand{\cdenexp}[2]{\mathcal{E}\llbracket #1 \rrbracket #2}
\newcommand{\cdenaexp}[2]{\mathcal{E}_a\llbracket #1 \rrbracket #2}
\newcommand{\cdendexp}[3]{\mathcal{E}_d\llbracket #1 \rrbracket #2 #3}
\newcommand{\cdenclause}[6]{\mathcal{C}\!\left\llbracket #1
  \right\rrbracket #2 #3 #4 #5 #6}
\newcommand{\cdencontext}[1]{\mathcal{D}\llbracket #1 \rrbracket}
\newcommand{\cdencontract}[1]{\mathcal{P}\llbracket #1 \rrbracket}

We now have a notion of well-typed \csl{} contracts, and in this
section we present a denotational semantics for \csl{}, which is a
compositional mapping of well-typed  \csl{} syntax to contract
functions as of Definition \ref{def:contract}. Since \csl{} permits
recursive definitions, we need to utilize domain theory
\cite{winskel93fsopl}, and the (pointed) cpos used in the denotation
functions for \csl{} are defined in Figure \ref{fig:domains}. 
\begin{figure}[b]
  \begin{align}
    C_A &= \timeset \to \contractsetlift{A}\label{dom1}\\
    \dendom{\Delta} &= \Pi_{f \in \dom{\Delta}}
    (\dendomlift{\pi_1(\Delta(f))} \to \Pi_{\vec{a} \in
      \agentset^{\pi_2(\Delta(f))}}C_{\vec{a}}) \label{dom2}\\
    & \mbox{ where }
    \dendomlift{(\type_1,\ldots,\type_n)} =
    (\dendom{\type_1},\ldots,\dendom{\type_n}) \notag\\
    \dendom{\Lambda} &= \Lambda \to \agentset \label{dom3}\\
    \dendom{\Gamma} &= \Pi_{x \in \dom{\Gamma}}
    \dendom{\Gamma(x)} \label{dom4}\\
    \dendom{\ctclause{\Delta}{\Lambda}{\Gamma}{c}{A}} &=
    \dendom{\Delta} \to (\Pi_{\lambda \in 
      \dendom{\Lambda}} (\dendom{\Gamma} \to C_{A \cup
      \cod{\lambda}})) \label{dom6}\\
    \dendom{\ctcontext{D}{\Delta}} &=
    \dendom{\Delta} \label{dom7}\\
    \dendom{\ctcontract{p}{A}} &= \contractsetlift{A} \label{dom8}.
  \end{align}
  \caption{The domains of \csl{}.}\label{fig:domains}
\end{figure}
The abbreviation $C_A$ (\ref{dom1}) is for \emph{clause functions}: a
clause function corresponds to the earlier mentioned pre contract, in the
sense that it has to be supplied first with a base point in time in
order to be a contract. Furthermore, since we have recursive definitions, we
lift the contract function space to a \emph{pointed} cpo, where $\bot$
represents divergence (we will later present a sufficient condition
for guaranteeing that \csl{} contracts always converge, essentially
disallowing recursive definitions such as $f()\langle\rangle =
f()\langle\rangle$, which are otherwise well-typed). We abuse
notation in (\ref{dom2}) by writing 
$C_{\vec{a}}$, which means $C_A$, where $A$ is the set of agents
occurring in the vector $\vec{a}$. The definition of $\dendom{\Gamma}$
uses the denotation function for types from the signature $S$, so for
instance
\[
\dendom{[x \mapsto
  \ctpnat, y \mapsto \ctpagent]} = \left\{ f : \{x,y\} \to \nat \uplus
\agentset \mathbin{|} f(x) \in \nat \land f(y) \in \agentset \right\}.
\]
All partial orders on function spaces are
defined as the point-wise ordering with respect to the order on the codomain
(i.e., $f \sqsubseteq g$ iff $\forall x. f(x) \sqsubseteq g(x)$),
which automatically makes the function spaces (pointed) cpos,
provided that the codomains are (pointed) cpos. For all point-wise
ordered cpos, we use $\sqsubseteq$ to denote the order.
\begin{lemma}\label{lemma:cpos}
  The domains in Figure \ref{fig:domains} are all (pointed) cpos.
\end{lemma}
\begin{proof}
  \begin{inparaenum}
  \item[(\ref{dom1})] is a pcpo, because it is the point-wise ordering,
    and $\verdictset{A}$ is a discrete cpo;
  \item[(\ref{dom2})] is a pcpo, because it is the point-wise ordering,
    and $C_{\vec{a}}$ is a pcpo;
  \item[(\ref{dom3}) and (\ref{dom4})] are cpos with the discrete order;
  \item[(\ref{dom6})] is a pcpo, because it is the point-wise
    ordering, and the codomain is a pcpo;
  \item[(\ref{dom7}) = (\ref{dom2})] is a pcpo; and
  \item[(\ref{dom8})] is a pcpo, because it is the point-wise
    ordering, and the codomain is a pcpo.
  \end{inparaenum}
  \qed
\end{proof}

The first denotation functions we define are for expressions,
$\cdenexp{\cdot}{}$, agent expressions, $\cdenaexp{\cdot}{}$,
and deadline expressions, $\cdendexp{\cdot}{}$, Figure
\ref{fig:denexp}.
\begin{figure}[b!]
  \begin{center}
    \begin{align*}
     \cdenexp{\ctexp{\Gamma}{e}{\type}}{} &: \dendom{\Gamma} \to
      \dendom{\type}\\
      \cdenexp{x}{\gamma} &= \gamma(x)\\
      \cdenexp{d}{\gamma} &= d\\
      \cdenexp{e \textsf{D}}{\gamma} &= 24 * 60 * 60 *
      \cdenexp{e}{\gamma}\\
      \cdenexp{e \textsf{W}}{\gamma} &= 7 * 24 * 60 * 60 *
      \cdenexp{e}{\gamma}\\
      \cdenexp{e_1 \circ e_2}{\gamma} &= \cdenexp{e_1}{\gamma} \circ
      \cdenexp{e_2}{\gamma}, \mbox{ where } \circ \in \{+,-,*,/\}\\
      \cdenexp{e_1 \mathbin{--} e_2}{\gamma} &= \max(0,\cdenexp{e_1}{\gamma} -
      \cdenexp{e_2}{\gamma})\\
      \cdenexp{e_1 \mathbin{\candalso} e_2}{\gamma} &=
      \cdenexp{e_1}{\gamma} \land \cdenexp{e_2}{\gamma}\\
      \cdenexp{e_1 \prec e_2}{\gamma} &= \cdenexp{e_1}{\gamma} \prec
      \cdenexp{e_2}{\gamma}, \mbox{ where} \prec \in \{<,\leq,=\}\\
      \\
      \cdenaexp{\ctaexp{\Lambda}{e_a}{A}}{} &: \dendom{\Lambda} \to
      \agentset\\
      \cdenaexp{e_a}{\lambda} &= \left\{
        \begin{array}{ll}
          a, & \mbox{ if } e_a = a\\
          \lambda(x), & \mbox{ if } e_a = x
        \end{array}
      \right.\\
      \\
      \cdendexp{\ctdexp{\Gamma}{e_d}}{}{} &: \dendom{\Gamma} \to \timeset
      \to \left\{ [t_1;t_2] \subseteq \timeset \mathbin{|} t_1
        \leq t_2 \right\}\\
      \cdendexp{\cwithinafter{e_1}{e_2}}{\gamma}{t} &= [t +
      \cdenexp{e_2}{\gamma}; t +
      \cdenexp{e_1}{\gamma} +
      \cdenexp{e_2}{\gamma}]
    \end{align*}
  \end{center}
  \caption{Denotations for expressions, agent expressions, and
    deadline expressions.}
  \label{fig:denexp}
\end{figure}
Since all deadlines are relative, the denotation
function for deadline expressions expects an absolute time value as
argument. The denotations are only defined for well-typed
(agent/deadline) expressions, but instead of writing,
e.g., $\cdenexp{\ctexp{\Gamma}{x}{\type}} = \cdots$ we simply write
$\cdenexp{x} = \cdots$.

\begin{lemma}[$\cdenexp{\cdot}{}$, $\cdenaexp{\cdot}{}$, and
  $\cdendexp{\cdot}{}$ are well-defined]
  For a well-typed expression, $\ctexp{\Gamma}{e}{\type}$, a well-typed
  agent expression, $\ctaexp{\Lambda}{e_a}{A}$, and a well-typed
  deadline expression, $\ctdexp{\Gamma}{e_d}$, the functions
  $\cdenexp{e} : \dendom{\Gamma} \to \dendom{\type}$, $\cdenaexp{e_a} :
  \dendom{\Lambda} \to \agentset$, and $\cdendexp{e_d} : \dendom{\Gamma}
  \to \timeset \to \left\{ [t_1;t_2] \subseteq \timeset \mathbin{|} t_1
    \leq t_2 \right\}$ are well-defined.
\end{lemma}
\begin{proof}
  Follows by induction on the typing derivations. (Note that the
  restriction to the ``monus'' operator in subtraction of $\ctpduration$
  values is needed to guarantee that $t_1,t_2 \in \timeset = \nat$ and
  $t_1 \leq t_2$.)
  \qed
\end{proof}

We next define a denotation function for well-typed clauses,
$\cdenclause{\cdot}{}{}{}{}{}$,
in Figure \ref{fig:cdenclausecontract}.
\begin{figure}
  \fbox{$\cdenclause{\ctclause{\Delta}{\Lambda}{\Gamma}{c}{A}}{}{}{}{}{}
    : \dendom{\ctclause{\Delta}{\Lambda}{\Gamma}{c}{A}}$}
  \begin{align*}
    \cdenclause{\cempty}{\delta}{\lambda}{\gamma}{t}{\trace} &=
    \left\{
      \begin{array}{ll}
        \lift{\conforming}, & \mbox{if } \trace = \emptytrace\\
        \lift{(t',\{a\})},& \mbox{if } \trace =
        \event{t'}{a}{\choice}{k(\vec{d})} \trace'
      \end{array}
    \right.\\
    \cdenclause{\begin{array}{l}\catomic{e_a}{k(\vec{x})}{x\\}{e}{e_d\\}{c}\end{array}}{\!\delta}{\lambda}{\gamma}{t}{\trace}
    &= \left\{
      \begin{array}{llr}
        \cdenclause{c}{\delta}{\lambda}{\gamma'}{(t'+1)}{\trace'}, &
        \mbox{if } \trace =
        \event{t'}{a}{\emptychoice}{k(\vec{d})}\trace'\ \land &
        \hspace{10pt}\mbox{(a)}\\
        &\hspace{9pt} t' \in \cdendexp{e_d}{\gamma}{t}\
        \land\\
        &\hspace{9pt} \cdenaexp{e_a}{\lambda} = a\ \land\\
        &\hspace{9pt} \cdenexp{e}{\gamma[\vec{x} \mapsto \vec{d}]} =
        \ctrue\ \land\\
        &\hspace{9pt} \gamma' = \gamma[\vec{x} \mapsto \vec{d}, x
        \mapsto t' - t]\\
        \lift{(t_2,\{\cdenaexp{e_a}{\lambda}\})}, & \mbox{if }
        \cdendexp{e_d}{\gamma}{t} = [t_1;t_2]\ \land & \mbox{(b)}\\
        &\hspace{9pt} (\trace = \emptytrace \lor
        \tracestart(\trace) > t_2)\\
        \lift{(t',\{a\})}, & \mbox{otherwise, where } & \mbox{(c)}\\
        &\hspace{9pt} \trace =
        \event{t'}{a}{\choice}{k'(\vec{d})}\trace'
      \end{array}
   \right.\\
   \cdenclause{\begin{array}{l}\catomicp{\vec{e_a}}{k(\vec{x})}{x\\}{e}{e_d\\}{c_1}{c_2}\end{array}}{\!\delta}{\lambda}{\gamma}{t}{\trace}
   &= \left\{
      \begin{array}{llr}
        \cdenclause{c_1}{\delta}{\lambda}{\gamma'}{(t'+1)}{\trace'}, &
        \mbox{if } \trace =
        \event{t'}{a}{\emptychoice}{k(\vec{d})}\trace'\ \land&
        \hspace{2.5pt} \mbox{(a')}\\
        &\hspace{9pt} t' \in \cdendexp{e_d}{\gamma}{t}\ \land\\
        &\hspace{9pt} \exists e_{a_i} \in \vec{e_a}. \cdenaexp{e_{a_i}}{\lambda} = a\ \land\\
        &\hspace{9pt} \cdenexp{e}{\gamma[\vec{x} \mapsto \vec{d}]} =
        \ctrue\ \land\\
        &\hspace{9pt} \gamma' = \gamma[\vec{x} \mapsto \vec{d}, x
        \mapsto t' - t]\\
        \cdenclause{c_2}{\delta}{\lambda}{\gamma}{(t_2+1)}{\trace}, &
        \mbox{if } \cdendexp{e_d}{\gamma}{t} = [t_1;t_2]\ \land &
        \mbox{(b')}\\
        &\hspace{9pt} (\trace = \emptytrace \lor
        \tracestart(\trace) > t_2)\\
        \lift{(t',\{a\})}, & \mbox{otherwise, where } & \mbox{(c')}\\
        &\hspace{9pt} \trace =
        \event{t'}{a}{\choice}{k'(\vec{d})}\trace'
      \end{array}
    \right.\\
    \cdenclause{\canddefault}{\delta}{\lambda}{\gamma}{t}{} &=
    \cdenclause{c_1}{\delta}{\lambda}{\gamma}{t}{} \otimes_\bot
    \cdenclause{c_2}{\delta}{\lambda}{\gamma}{t}{}\\
    \cdenclause{\cordefault}{\delta}{\lambda}{\gamma}{t}{} &=
    \cdenclause{c_1}{\delta}{\lambda}{\gamma}{t}{} \oplus_\bot
    \cdenclause{c_2}{\delta}{\lambda}{\gamma}{t}{}\\
    \cdenclause{\cifthenelsedefault}{\delta}{\lambda}{\gamma}{}{}
    &= \left\{
      \begin{array}{ll}
        \cdenclause{c_1}{\delta}{\lambda}{\gamma}{}{}, & \mbox{if
        } \cdenexp{e}{\gamma} = \ctrue\\
        \cdenclause{c_2}{\delta}{\lambda}{\gamma}{}{}, & \mbox{if
        } \cdenexp{e}{\gamma} = \cfalse
      \end{array}
    \right.\\
    \cdenclause{\cinstantiatedefault}{\delta}{\lambda}{\gamma}{}{}
    &=
    \delta(f)(\cdenexp{\vec{e}}{\gamma})(\cdenaexp{\vec{e_a}}{\lambda})
  \end{align*}

  \proofsep{}

  \fbox{$\cdencontext{\ctcontext{D}{\Delta}} :
    \dendom{\ctcontext{D}{\Delta}}$}
  \begin{align*}
    \cdencontext{\{\cinstantiate{f_i}{\vec{x_i}}{\vec{y_i}} =
      c_i\}_{i = 1}^n} &= \mathit{fix}(\Phi),\\
    \mbox{where } \Phi(\delta)(f_i)(\vec{d_i})(\vec{a_i}) &=
    \cdenclause{c_i}{\delta}{[\vec{y_i} \mapsto
      \vec{a_i}]}{[\vec{x_i} \mapsto \vec{d_i},\vec{y_i} \mapsto
      \vec{a_i}]}{}
  \end{align*}

  \proofsep{}

  \fbox{$\cdencontract{\ctcontract{p}{A}} :
    \dendom{\ctcontract{p}{A}}$}
  \begin{align*}
    \cdencontract{\ccontract{D}{c}{t}} &=
    \cdenclause{c}{\cdencontext{D}}{\emptyset}{\emptyset}{t}
  \end{align*}
  \caption{Denotational semantics for \csl{} clauses, template
    definitions, and contracts.}
  \label{fig:cdenclausecontract}
\end{figure}
The denotation is a mapping from \csl{} clauses to clause functions
(i.e., functions of type $C_A$). Since we have lifted the verdict domain,
$\verdictset{A}$, to accomodate potential nontermination,
$\verdictsetlift{A}$, we use lifted versions of contract conjunction
and contract disjunction, $\otimes_\bot$ and $\oplus_\bot$, i.e.,
\begin{align*}
  (\contract_1 \otimes_\bot \contract_2)(\trace) &= \left\{ \begin{array}{ll}
      \bot, &\mbox{if } \contract_1(\trace_1) = \bot \lor \contract_2(\trace_2) =
      \bot\\
      \lift{v_1 \otimes v_2}, &\mbox{if } \contract_1(\trace_1) = \lift{v_1} \land
      \contract_2(\trace_2) = \lift{v_2}
    \end{array}\right.\\
  &\qquad \mbox{where } \tracesplit(\trace) = (\trace_1,\trace_2)\\
  (\contract_1 \oplus_\bot \contract_2)(\trace) &= \left\{ \begin{array}{ll}
      \bot, &\mbox{if } \contract_1(\trace) = \bot \lor \contract_2(\trace) =
      \bot\\
      \lift{v_1 \oplus v_2}, &\mbox{if } \contract_1(\trace) = \lift{v_1} \land
      \contract_2(\trace) = \lift{v_2}
    \end{array}\right. .
\end{align*}

There are three cases in the definition for atomic
obligations, which represent the following situations:
\begin{itemize}
\item[(a)] The deadline has not passed, $t' \in
  \cdendexp{e_d}{\gamma}{t}$, and the first event fulfills the 
  conditions of the atomic obligation, $\cdenaexp{e_a}{\lambda} = a
  \land \cdenexp{e}{\gamma[\vec{x} \mapsto \vec{d}]} = \ctrue$, so
  the residual clause $c$ and the remaining trace dictates the outcome;
\item[(b)] The deadline has passed, $\cdendexp{e_d}{\gamma}{t} =
  [t_1;t_2] \land (\trace = \emptytrace \lor \tracestart(\trace) >
  t_2)$, so the agent responsible for the obligation has violated the
  clause; and
\item[(c)] The deadline has not passed, and the first event does not
  fulfill the conditions of the atomic obligation, so the generator of
  the event has violated the clause.
\end{itemize}
The three cases for atomic permissions are similar:
\begin{itemize}
\item[(a')] The deadline has not passed, $t' \in
  \cdendexp{e_d}{\gamma}{t}$, and the first event fulfills
  the conditions of the atomic permission, $\exists
  e_{a_i} \in \vec{e_a}. \cdenaexp{e_{a_i}}{\lambda} = a \land \cdenexp{e}{\gamma[\vec{x}
    \mapsto \vec{d}]} = \ctrue$, so the residual clause $c_1$ and the
  remaining trace dictates the outcome;
\item[(b')] The deadline has passed, $\cdendexp{e_d}{\gamma}{t} =
  [t_1;t_2] \land (\trace = \emptytrace \lor \tracestart(\trace) >
  t_2)$, so $c_2$ dictates the outcome; and
\item[(c')] The deadline has not passed, and the first event does not
  fulfill the conditions of the atomic permission, so the generator of
  the event has violated the clause.
\end{itemize}
We abuse notation in the equation for template instantiations,
$\cdenclause{\cinstantiatedefault}{}{}{}{}{}$, where we implicitly
lift the denotations for (agent) expressions to vectors, i.e.,
\begin{align*}
  \cdenexp{(e_1,\ldots,e_n)}{\gamma} &=
  (\cdenexp{e_1}{\gamma},\ldots,\cdenexp{e_n}{\gamma})\\
  \cdenaexp{(e_{a_1},\ldots,e_{a_n})}{\lambda} &= 
  (\cdenaexp{e_{a_1}}{\lambda},\ldots,\cdenexp{e_{a_n}}{\lambda}).
\end{align*}

\defthm{lemma}{lemma:cdenclausewelldefined}{Lemma}{$\cdenclause{\cdot}{}{}{}{}{}$
  is well-defined}{
  Let $c$ be a well-typed clause, i.e.,
  $\ctclause{\Delta}{\Lambda}{\Gamma}{c}{A}$. Then
  $\cdenclause{c}{}{}{}{}{} :
  \dendom{\ctclause{\Delta}{\Lambda}{\Gamma}{c}{A}}$ is well-defined.
}
\begin{proof}
  The proof is included on page
  \pageref{proof:lemma:cdenclausewelldefined}. Note that this proof is
  nontrivial, since we need to check that the semantic disjunction,
  $\oplus$, is well-defined.
  \qed
\end{proof}

Since template definitions are recursive, we need to show that
templates define continuous functions. We therefore first show that
the denotation of a contract clause always defines a continuous
function.
\defthm{lemma}{lemma:cdenclausecont}{Lemma}{$\cdenclause{\cdot}{}{}{}{}{}$
is continuous}{
  Let $c$ be a well-typed clause, i.e.,
  $\ctclause{\Delta}{\Lambda}{\Gamma}{c}{A}$. Then
  $
  \cdenclause{c}{}{}{}{}{}{} : \dendom{\ctclause{\Delta}{\Lambda}{\Gamma}{c}{A}}
  $
  defines a continous function.
}
\begin{proof}
  The proof is included on page \pageref{proof:lemma:cdenclausecont}.
  \qed
\end{proof}

Having established that $\cdenclause{\cdot}{}{}{}{}{}$ is continuous,
we can define denotation functions for well-typed contract
definitions, $\cdencontext{\cdot}$, and full contracts,
$\cdencontract{\cdot}$, Figure \ref{fig:cdenclausecontract}.
\begin{lemma}[$\cdencontext{\cdot}$ and $\cdencontract{\cdot}$ are
  well-defined]\label{lemma:fix}
  For a well-typed template environment, $\ctcontext{D}{\Delta}$, and a
  well-typed contract, $\ctcontract{p}{A}$, the following functions are
  well-defined:
  \begin{align*}
    \cdencontext{D} &: \dendom{\ctcontext{D}{\Delta}}\\
    \cdencontract{p} &: \dendom{\ctcontract{p}{A}}.
  \end{align*}
\end{lemma}
\begin{proof}
  The only thing we need to show, is that the least fixed point,
  $\mathit{fix}(\Phi)$, exists. Now, since
  $\cdenclause{c_i}{}{}{}{}$ defines a continous function for each
  $i$ (Lemma \ref{lemma:cdenclausecont}), it follows from the point-wise
  ordering on $\dendom{\Delta}$ that $\Phi :\dendom{\Delta} \to
  \dendom{\Delta}$ defines a continous function. But $\dendom{\Delta}$
  is a pcpo (Lemma \ref{lemma:cpos}) so it follows that the least
  fixed point exists \cite[Theorem 8.3]{winskel93fsopl}.
  \qed
\end{proof}

We have now shown that the denotation of a \csl{} contract has the
right \emph{type} (modulo diverging contract definitions, which we
treat in Section \ref{sec:guarded}), but we still need to show that
the condition (\ref{def:contract1}) of Definition \ref{def:contract}
is satisfied. In order to show this we generalize condition
(\ref{def:contract1}) to clause functions:
\begin{definition}\label{def:predicate}
The property, $P \subseteq C_A$, is defined by:
\begin{align*}
P(f) & \mbox{ iff } \forall t_0 \in \timeset. \forall \trace \in
\traceset{A}. f(t_0)(\trace) = \lift{(t,B)} \Rightarrow\\
&\quad\quad \left(\begin{array}{l}
    \trace = \emptytrace \Rightarrow t \geq t_0\ \land\\
    \tracestart(\trace) = t' \Rightarrow t \geq \min(t_0,t')\ \land\\
    \forall \trace' \in \traceset{A}. \left( \trace_{t} = \trace'_{t} \land
    f(t_0)(\trace') \neq \bot \right) \Rightarrow f(t_0)(\trace') = \lift{(t,B)}
  \end{array}\right) .\notag
\end{align*}
$P$ is lifted to template environments, $P \subseteq \dendom{\Delta}$,
where $P(\delta)$ holds whenever $P(\delta(f)(\vec{d})(\vec{a}))$
holds for all $f \in \dom{\Delta}$, $\vec{d} \in
\dendomlift{\pi_1(\Delta(f))}$, and $\vec{a} \in
\agentset^{\pi_2(\Delta(f))}$.
\end{definition}

\defthm{lemma}{lemma:inclusive}{Lemma}{$P$ is inclusive}{
  The predicate $P \subseteq \dendom{\Delta}$ is inclusive for all
  template typing environments $\Delta$, i.e., for every chain,
  $\delta_0 \sqsubseteq \delta_1 \sqsubseteq \cdots$, in
  $\dendom{\Delta}$, whenever $P(\delta_i)$ for all $i$, then
  $P(\bigsqcup_i \delta_i)$.
}
\begin{proof}
  The proof is included on page \pageref{proof:lemma:inclusive}.
  \qed
\end{proof}

\defthm{lemma}{lemma:cpreservesp}{Lemma}{$\cdenclause{\cdot}{}{}{}{}{}$
preserves $P$}{
  Let $c$ be a well-typed clause,
  $\ctclause{\Delta}{\Lambda}{\Gamma}{c}{A}$.
  Then for any $\delta \in \dendom{\Delta}$, $\lambda \in
  \dendom{\Lambda}$, $\gamma \in \dendom{\Gamma}$,
  $P(\cdenclause{c}{\delta}{\lambda}{\gamma}{}{})$ holds, provided that
  $P(\delta)$  holds.
}
\begin{proof}
  The proof is included on page \pageref{proof:lemma:cpreservesp}.
  \qed
\end{proof}

We can now show the main result of our denotational translation, i.e.,
that the denotation of a \csl{} contract defines a contract (assuming
termination of the recursive definitions).
\begin{theorem}\label{theorem:contract}
  For a well-typed \csl{} contract over signature $S$,
  $\ctcontract{p}{A}$, if $\cdencontract{p}(\trace) \neq \bot$ for all $\trace$, then
  $\cdencontract{p}$ defines a contract involving agents $A$ over
  signature $S$, as of Definition \ref{def:contract}.
\end{theorem}
\begin{proof}
  The fact that the mapping is well-defined follows from Lemma
  \ref{lemma:fix} and the assumption then guarantees that
  $\cdencontract{p} : \contractset{A}$. So it remains to
  show that $\cdencontract{p}$ satisfies the condition
  (\ref{def:contract1}). Recall the predicate $P$ from Definition
  \ref{def:predicate}: if we can show $P(\bot_{\dendom{\Delta}})$ and
  $P(\delta) \Rightarrow P(\Phi(\delta))$, then it follows by fixed
  point induction that $P(\mathit{fix}(\Phi))$ holds:
  \begin{itemize}\itemsep=5pt
  \item[$P(\bot_{\dendom{\Delta}})$:] Now
    $\bot_{\dendom{\Delta}}(f)(\vec{d})(\vec{a})(t)(\trace) = \bot$,
    for all $f$, $\vec{d}$, $\vec{a}$, $t$, and $\trace$, so
    $P(\bot_{\dendom{\Delta}})$ is trivially satisfied.
  \item[$P(\delta) \Rightarrow P(\Phi(\delta))$:] This is the result of
    Lemma \ref{lemma:cpreservesp}.
  \end{itemize}
  
  By fixed-point induction we can then conclude that
  $P(\cdencontext{D})$ holds, hence by Lemma
  \ref{lemma:cpreservesp} it follows that
  $P(\cdenclause{c}{\cdencontext{D}}{\emptyset}{\emptyset}{})$
  holds. But then by the definition of $P$ (Definition
  \ref{def:predicate}), it follows that
  $\cdenclause{c}{\cdencontext{D}}{\emptyset}{\emptyset}{t}$ satisfies
  the property (\ref{def:contract1}).
  \qed
\end{proof}

\begin{corollary}\label{corollary:p}
  Let $c$ be a well-typed clause,
  $\ctclause{\Delta}{\Lambda}{\Gamma}{c}{A}$. 
  Then for any $\delta \in \dendom{\Delta}$, $\lambda \in
  \dendom{\Lambda}$, $\gamma \in \dendom{\Gamma}$, if
  $\cdenclause{c}{\delta}{\lambda}{\gamma}{t_0}{\trace} =
  \lift{(t,B)}$, then either $\trace = \emptytrace \land t \geq t_0$,
  or $\trace \neq \emptytrace \land t \geq
  \min(t_0,\tracestart(\trace))$.
\end{corollary}
\begin{proof}
  The proof follows by fixed-point induction, similar to the proof of
  Theorem \ref{theorem:contract}.
  \qed
\end{proof}

\subsubsection{Guarded specifications}\label{sec:guarded}
\newcommand{\guarded}{\mathrm{Guarded}}
\newcommand{\cguarded}[3]{#1, #2 \vdash #3 : \guarded}
As mentioned in the previous section, not all \csl{} specifications
denote contracts, due to the possibility of non-terminating,
recursive definitions, e.g.
\begin{lstlisting}[language=csl]
letrec
f()<> = f()<>
in
f()<> starting 2010-06-01
\end{lstlisting}

In order to avoid such specifications, we follow Andersen et
al. \cite{andersen06contracts} and introduce \emph{guarded}
clauses. Guardedness will provide a sufficient condition for ensuring
that the unfolding of a template definition always terminates.
\begin{definition}[Guarded clause, guarded templates]
Let $c$ be a contract clause, and $D$ be a set of template
definitions. We say that $c$ is \emph{guarded} in $D$, if
$\cguarded{D}{\emptyset}{c}$ is 
derivable from the rules in Figure \ref{fig:cguarded}. $D$ is said to
be guarded, if $c_i$ is guarded in $D$ for all
$\cinstantiate{f_i}{\vec{x_i}}{\vec{y_i}} = c_i \in D$.
\end{definition}

\begin{figure}[!t]
  \fbox{$\cguarded{D}{F}{c}$}
  \vspace{-23pt}
  \begin{center}
    \AxiomC{}
    \UnaryInfC{$\cguarded{D}{F}{\cempty}$}
    \DisplayProof{}

    \proofsep

    \AxiomC{}
    \UnaryInfC{$\cguarded{D}{F}{\catomic{e_a}{k(\vec{x})}{x}{e}{e_d}{c}}$}
    \DisplayProof{}

    \proofsep

    \AxiomC{$\cguarded{D}{F}{c_2}$}
    \UnaryInfC{$\cguarded{D}{F}{\catomicp{\vec{e_a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}$}
    \DisplayProof{}

    \proofsep

    \AxiomC{$\cguarded{D}{F}{c_1}$}
    \AxiomC{$\cguarded{D}{F}{c_2}$}
    \BinaryInfC{$\cguarded{D}{F}{\canddefault}$}
    \DisplayProof{}

    \proofsep

    \AxiomC{$\cguarded{D}{F}{c_1}$}
    \AxiomC{$\cguarded{D}{F}{c_2}$}
    \BinaryInfC{$\cguarded{D}{F}{\cordefault}$}
    \DisplayProof{}

    \proofsep

    \AxiomC{$\cguarded{D}{F}{c_1}$}
    \AxiomC{$\cguarded{D}{F}{c_2}$}
    \BinaryInfC{$\cguarded{D}{F}{\cifthenelsedefault}$}
    \DisplayProof{}

    \proofsep

    \AxiomC{$f \not\in F$}
    \AxiomC{$\cinstantiate{f}{\vec{x}}{\vec{y}} = c \in D$}
    \AxiomC{$\cguarded{D}{F \cup \{f\}}{c}$}
    \TrinaryInfC{$\cguarded{D}{F}{\cinstantiatedefault}$}
    \DisplayProof{}
  \end{center}
  \caption{Guarded clauses.}
  \label{fig:cguarded}
\end{figure}

The following lemma shows that guarded template definitions
automatically imply guarded clauses, i.e., it is not possible to
construct a diverging contract clause using only converging template
definitions.
\begin{lemma}\label{lemma:guardednessbyconstruction}
  Let $D$ be a set of guarded template definitions. Then $c$ is guarded
  in $D$, for any \csl{} clause $c$.
\end{lemma}
\begin{proof}
  The derivation, $\cguarded{D}{\emptyset}{c}$, can be constructed by 
  structural induction on $c$. The only interesting case is $c \equiv
  \cinstantiatedefault$, where one needs to show that for any
  $\cinstantiate{f_i}{\vec{x_i}}{\vec{y_i}} = c_i \in D$, the
  derivation assumed to exist, $\cguarded{D}{\emptyset}{c_i}$, can
  always be converted to a derivation
  $\cguarded{D}{\{f_i\}}{c_i}$. (Formally this is a proof by induction
  on the derivation of $\cguarded{D}{\emptyset}{c_i}$, but we omit it
  here.)
  \qed
\end{proof}

Using the lemma above, we can now prove that a guarded set of template
definitions always give rise to a (proper) contract:
\defthm{theorem}{theorem:guardedness}{Theorem}{}{
  Let $D$ be a set of guarded template definitions, and assume that
  $\ctcontext{D}{\Delta}$ and
  $\ctclause{\Delta}{\Lambda}{\Gamma}{c}{A}$. Then
  $\cdenclause{c}{\cdencontext{D}}{\lambda}{\gamma}{t}{\trace} \neq
  \bot$, for all $\lambda \in \dendom{\Lambda}$, $\gamma \in
  \dendom{\Gamma}$, $t \in \timeset$ and $\trace \in \traceset{A \cup
    \cod{\lambda}}$.
}
\begin{proof}
  The proof is included on page \pageref{proof:theorem:guardedness}.
  \qed
\end{proof}

We can now collect the results of this section to show that
well-typed, guarded \csl{} specifications indeed denote contracts as
defined in section \ref{sec:tracemodel}.
\begin{corollary}[Well-typed, guarded \csl{} contracts \emph{are}
  contracts]
  Let $p \equiv \ccontract{D}{c}{t}$ be a well-typed \csl{} contract
  over signature $S$, $\ctcontract{p}{A}$, where $D$ is a guarded set
  of templates. Then $\cdencontract{p}$ defines a contract involving
  agents $A$ over signature $S$, as of Definition \ref{def:contract}.
\end{corollary}
\begin{proof}
  Since we have a derivation, $\ctcontract{\ccontract{D}{c}{t}}{A}$, it
  follows that $\ctcontext{D}{\Delta}$ and
  $\ctclause{\Delta}{\emptyset}{\emptyset}{c}{A}$. It then follows from
  Theorem \ref{theorem:guardedness} that
  $\cdencontract{\ccontract{D}{c}{t}} \trace \neq \bot$, for all $\trace
  \in \traceset{A}$, which combined with the result of Theorem
  \ref{theorem:contract} yields the desired result.
  \qed
\end{proof}

\section{Run-time monitoring of
  \csl{}}\label{sec:runtimemonitoringcsl}
\newcommand{\ceval}[2]{#1 \Downarrow #2}
\newcommand{\cevald}[2]{#1 \Downarrow #2}
\newcommand{\cupdate}[5]{#1,#2,#3 \vdash #4 \leadsto #5}
\newcommand{\cstep}[5]{#1, #2 \vdash #3 \stackrel{#4}{\rightarrow} #5}
\newcommand{\cnullable}[2]{#1 \vdash #2 : \partialok}

We saw in the last section that well-typed, guarded \csl{} contracts
represent contracts as defined in section \ref{sec:tracemodel}. In
this section we define a small-step, substitution-based, operational
semantics for \csl{}, and prove that it gives rise to a run-time
monitoring algorithm for \csl{} contracts, as defined in section
\ref{sec:runtimemonitoring}. We first define evaluation relations for
deadline expressions and general expressions in Figure
\ref{fig:ceval}. (There is no relation for agent expressions, since
only agent constants will occur at top-level in a well-typed \csl{}
contract.)
\begin{figure}[b]
  \fbox{$\ceval{e}{d}$}
  \vspace{-23pt}
  \begin{center}
    \AxiomC{}
    \UnaryInfC{$\ceval{d}{d}$}
    \DisplayProof{}
    \quad\quad
    \AxiomC{$\ceval{e}{n}$}
    \UnaryInfC{$\ceval{e \mathsf{D}}{24*60*60*n}$}
    \DisplayProof{}
    \quad\quad
    \AxiomC{$\ceval{e}{n}$}
    \UnaryInfC{$\ceval{e \mathsf{W}}{7*24*60*60*n}$}
    \DisplayProof{}
    
    \proofsep

    \AxiomC{$\ceval{e_1}{n_1}$}
    \AxiomC{$\ceval{e_2}{n_2}$}
    \BinaryInfC{$\ceval{e_1 \mathbin{--} e_2}{\max(0,n_1-n_2)}$}
    \DisplayProof{}
    \quad\quad
    \AxiomC{$\ceval{e_1}{b_1}$}
    \AxiomC{$\ceval{e_2}{b_2}$}
    \BinaryInfC{$\ceval{e_1 \mathbin{\candalso} e_2}{b_1 \land b_2}$}
    \DisplayProof{}

    \proofsep

    \AxiomC{$\ceval{e_1}{d_1}$}
    \AxiomC{$\ceval{e_2}{d_2}$}\RightLabel{$\circ \in \{+,-,*,/\}$}
    \BinaryInfC{$\ceval{e_1 \circ e_2}{d_1 \circ d_2}$}
    \DisplayProof{}
    \quad\quad
    \AxiomC{$\ceval{e_1}{d_1}$}
    \AxiomC{$\ceval{e_2}{d_2}$}\RightLabel{$\prec \in \{<,\leq,=\}$}
    \BinaryInfC{$\ceval{e_1 \prec e_2}{d_1 \prec d_2}$}
    \DisplayProof{}
  \end{center}
  \fbox{$\cevald{e_d}{(n_1,n_2)}$}
  \vspace{-23pt}
  \begin{center}
    \AxiomC{$\ceval{e_1}{n_1}$}
    \AxiomC{$\ceval{e_2}{n_2}$}
    \BinaryInfC{$\cevald{\cwithinafter{e_1}{e_2}}{(n_1,n_2)}$}
    \DisplayProof{}
  \end{center}
  \caption{Evaluation of general expressions and deadline expressions.}
  \label{fig:ceval}
\end{figure}
We then need to check that the evaluation rules are sound and complete
with respect to the denotational semantics:
\begin{lemma}[Soundness and adequacy of expression evaluation]\label{lemma:soundcompleteexp}
$\ceval{e}{d}$ iff $\cdenexp{e}{\emptyset} = d$ and
$\cevald{e_d}{(n_1,n_2)}$ iff $\cdendexp{e_d}{\emptyset}{t} =
[t+n_1;t+n_1 + n_2]$.
\end{lemma}
\begin{proof}
  Follows immediately from the definitions (they are essentially the
  same).
  \qed
\end{proof}

As mentioned above, the execution semantics of \csl{} is substitution
based. We therefore define substitution of general expressions and
substitution of agent values in Figure \ref{fig:substitutions}.
\begin{figure}
  \fbox{$e'[e/x]$}
  \vspace{-25pt}
  \begin{center}
    $\begin{array}{rclrcl}
      y[e/x] &=& \left\{ \begin{array}{ll}
          e, & \mbox{if } x = y\\
          y, & \mbox{otherwise}
        \end{array} \right. & \qquad\qquad
      (e' \textsf{W})[e/x] &=& e'[e/x] \textsf{W}\\
      d[e/x] &=& d &
      (e_1 \circ e_2)[e/x] &=& e_1[e/x] \circ e_2[e/x]\\
      (e' \textsf{D})[e/x] &=& e'[e/x] \textsf{D}&
      (e_1 \prec e_2)[e/x] &=& e_1[e/x] \prec e_2[e/x]\\
    \end{array}$
  \end{center}
  \vspace{-5pt}
  \fbox{$e_d[e/x]$}
  \vspace{-23pt}
  \begin{center}
    $(\cwithinafter{e_1}{e_2})[e/x] = \cwithinafter{e_1
      [e/x]}{e_2[e/x]}$
  \end{center}
  \fbox{$c[e/x]$}
  \vspace{-8pt}
  \begin{center}
    $\begin{array}{ll}
      \cempty[e/x] &=\\
      \quad \cempty\\
      (\catomic{e_a}{k(\vec{y})}{y}{e'}{e_d}{c})[e/x] &=\\
      \quad \left\{\begin{array}{ll}
          \catomic{\vec{e_a}}{k(\vec{y})}{y}{e'}{e_d[e/x]}{c},
          & \mbox{if } x \in \vec{y}\\
          \catomic{\vec{e_a}}{k(\vec{y})}{y}{e'[e/x]}{e_d[e/x]}{c},
          & \mbox{if } x \not\in \vec{y} \land x=y\\
          \catomic{\vec{e_a}}{k(\vec{y})}{y}{e'[e/x]}{e_d[e/x]}{c[e/x]},
          & \mbox{otherwise}
        \end{array} \right.\\
      (\catomicp{\vec{e_a}}{k(\vec{y})}{y}{e'}{e_d}{c_1}{c_2})[e/x]
      &=\\
      \quad \left\{\begin{array}{ll}
          \catomicp{\vec{e_a}}{k(\vec{y})}{y}{e'}{e_d[e/x]}{c_1}{c_2[e/x]},
          & \mbox{if } x \in \vec{y}\\
          \catomicp{\vec{e_a}}{k(\vec{y})}{y}{e'[e/x]}{e_d[e/x]}{c_1}{c_2[e/x]},
          & \mbox{if } x \not\in \vec{y} \land x=y\\
          \catomicp{\vec{e_a}}{k(\vec{y})}{y}{e'[e/x]}{e_d[e/x]}{c_1[e/x]\\\hspace{165pt}}{c_2[e/x]},
          & \mbox{otherwise}
        \end{array} \right.\\
      (\canddefault)[e/x] &=\\
      \quad\cand{c_1[e/x]}{c_2[e/x]}\\
      (\cordefault)[e/x] &=\\
      \quad\cor{c_1[e/x]}{c_2[e/x]}\\
      (\cifthenelse{e'}{c_1}{c_2})[e/x] &=\\
      \quad\cifthenelse{e'[e/x]}{c_1[e/x]}{c_2[e/x]}\\
      \cinstantiate{f}{e_1,\ldots,e_n}{\vec{e_a}}[e/x] &=\\
      \quad \cinstantiate{f}{e_1[e/x], \ldots, e_n[e/x]}{\vec{e_a}}
    \end{array}$
  \end{center}
  \fbox{$e_a \langle a/x \rangle$}
  \vspace{-25pt}
  \begin{center}
    $\begin{array}{rclrcl}
      y \langle a/x \rangle &= \left\{ \begin{array}{ll}
          a, & \mbox{if } x = y\\
          y, &\mbox{otherwise}
        \end{array} \right. &\qquad\qquad
      a' \langle a/x \rangle &= a'
    \end{array}$
  \end{center}
  \vspace{-6pt}
  \fbox{$c \langle a/x \rangle$}
  \vspace{-8pt}
  \begin{center}
    $\begin{array}{lll}
      \cempty \langle a/x \rangle &=\\
      \quad \cempty\\
      (\catomic{e_a}{k(\vec{y})}{y}{e}{e_d}{c}) \langle a/x \rangle &=\\
      \quad\catomic{e_a \langle a/x \rangle}{k(\vec{y})}{y}{e}{e_d}{c \langle a/x \rangle}\\
      (\catomicp{e_{a_1},\ldots,e_{a_n}}{k(\vec{y})}{y}{e}{e_d}{c_1}{c_2}) \langle a/x \rangle &=\\
      \quad\catomicp{e_{a_1} \langle a/x \rangle, \ldots, e_{a_n} \langle a/x
        \rangle}{k(\vec{y})}{y}{e}{e_d}{c_1 \langle a/x \rangle}{c_2
        \langle a/x \rangle}\\
      (\canddefault) \langle a/x \rangle &=\\
      \quad \cand{c_1\langle a/x \rangle}{c_2\langle a/x \rangle}\\
      (\cordefault)\langle a/x \rangle &=\\
      \quad \cor{c_1\langle a/x \rangle}{c_2\langle a/x \rangle}\\
      (\cifthenelse{e}{c_1}{c_2})\langle a/x \rangle &=\\
      \quad\cifthenelse{e}{c_1\langle a/x \rangle}{c_2\langle a/x \rangle}\\
      \cinstantiate{f}{\vec{e}}{e_{a_1},\ldots,e_{a_n}}\langle a/x \rangle &=\\
      \quad \cinstantiate{f}{\vec{e}}{e_{a_1}\langle a/x \rangle, \ldots, e_{a_n}\langle a/x \rangle}
    \end{array}$
  \end{center}
  \caption{Substitution of general expression $e$ for variable $x$ into
    (deadline) expression and clause ($e'[e/x]$, $e_d[e/x]$, and
    $c[e/x]$), and substitution of agent value $a$ for variable $x$
    into agent expression and clause ($e_a \langle a/x \rangle$ and $c
    \langle a/x \rangle$).}
  \label{fig:substitutions}
\end{figure}
$c[e/x]$ denotes the capture-avoiding substitution of expression $e$
for variable $x$ in clause $c$, where capture-avoidance means that the
variables bound in atomic clauses are not substituted. $c \langle a/x
\rangle$ denotes the substitution of agent $a$ for variable $x$ in
clause $c$, and since none of the variables in atomic clauses have
scope in agent expressions, there is no need to check for
capture-avoidance. All substitutions are lifted to multiple
substitutions, e.g., $c[e_1/x_1, \ldots, e_n/x_n] = c[e_1/x_1] \cdots
[e_n/x_n]$ and $c\langle a_1/x_1, \ldots, a_n/x_n \rangle = c \langle
a_1/x_1 \rangle \cdots \langle a_n/x_n \rangle $, and 
we will abuse notation by writing vectors of expressions/variables,
e.g., $c[\vec{e}/\vec{x}] = c[e_1/x_1, \ldots, e_n/x_n]$, where
$\vec{e} = (e_1,\ldots,e_n)$ and $\vec{x} = (x_1,\ldots,x_n)$.

\begin{lemma}[Substitution Lemma, Expressions]\label{lemma:substexp}
  Consider a well-typed expression, $\ctexp{\Gamma \cup [x \mapsto
    \type]}{e'}{\type'}$, a well-typed deadline expression,
  $\ctdexp{\Gamma \cup [x \mapsto \type]}{e_d}$, and a well-typed
  expression, $\ctexp{\Gamma}{e}{\type}$. Then
  \begin{align*}
    \ctexp{\Gamma}{e'[e/x]&}{\type'}\\
    \cdenexp{e'[e/x]}{\gamma} &= \cdenexp{e'}{\gamma[x \mapsto
      \cdenexp{e}{\gamma}]}\\
    \ctdexp{\Gamma}{e_d[e/x]&}\\ 
    \cdendexp{e_d[e/x]}{\gamma} &=
    \cdendexp{e_d}{\gamma[x \mapsto \cdenexp{e}{\gamma}]},
  \end{align*}
  for all $\gamma \in \dendom{\Gamma}$.
\end{lemma}
\begin{proof}
  The first two results follow easily by induction on the typing
  derivation, $\ctexp{\Gamma \cup [x \mapsto \type]}{e'}{\type'}$, and
  the latter two results follow immediately from the former.
  \qed
\end{proof}

\defthm{lemma}{lemma:substclause}{Lemma}{Substitution Lemma, Clauses}{
  Consider a well-typed clause,
  $\ctclause{\Delta}{\Lambda}{\Gamma \cup [x \mapsto \type]}{c}{A}$, and a
  well-typed expression, $\ctexp{\Gamma}{e}{\type}$. Then
  \begin{align*}
    \ctclause{\Delta}{\Lambda}{\Gamma}{c[e/x]&}{A}\\
    \cdenclause{c[e/x]}{\delta}{\lambda}{\gamma} &=
    \cdenclause{c}{\delta}{\lambda}{\gamma[x \mapsto
      \cdenexp{e}{\gamma}]},
  \end{align*}
 for all $\delta \in \dendom{\Delta}$, $\lambda \in \dendom{\Lambda}$,
 and $\gamma \in \dendom{\Gamma}$.
}
\begin{proof}
  The proof is included on page \pageref{proof:lemma:substclause}.
  \qed
\end{proof}

The substitution lemma for agent substitutions shows that agent
variables are indeed typed relevant, i.e., replacing an agent variable
$x$ with an agent $a$ will add $a$ to the set of agents.
\defthm{lemma}{lemma:substagent}{Lemma}{Agent Substitution Lemma}{
  Consider a well-typed clause,
  $\ctclause{\Delta}{\Lambda}{\Gamma}{c}{A}$, with $x \in \Lambda$. Then
  \begin{align*}
    \ctclause{\Delta}{\Lambda \setminus \{x\}}{\Gamma}{c \langle a/x \rangle&}{A \cup
      \{a\}}\\
    \cdenclause{c \langle a/x \rangle}{\delta}{\lambda}{}{}{} &=
    \cdenclause{c}{\delta}{\lambda[x \mapsto
      a]}{}{}{},
  \end{align*}
  for all $\delta \in \dendom{\Delta}$, $\lambda \in \dendom{\Lambda}$,
  and $a \in \agentset$.
}
\begin{proof}
  The proof is included on page \pageref{proof:lemma:substagent}.
  \qed
\end{proof}

We have now defined the substitution mechanisms which will be used in
the operational semantics of \csl{}. We then proceed with the
definition of an \emph{update} relation for well-typed, closed clauses
in Figure \ref{fig:cupdate}.
\begin{figure}
  \fbox{$\cupdate{D}{t_0}{t}{c}{r}$}
  \vspace{-20pt}
  \begin{center}
    \AxiomC{}
    \UnaryInfC{$\cupdate{D}{t_0}{t}{\cempty}{\cempty}$}
    \DisplayProof{}

    \proofsep{}

    \AxiomC{$\cevald{e_d}{(n_1,n_2)}$}
    \AxiomC{$t-t_0 > n_1 + n_2$}
    \BinaryInfC{$\cupdate{D}{t_0}{t}{\catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c}}{(t_0+n_1+n_2,\{a\})}$}
    \DisplayProof{}

    \proofsep{}

    \AxiomC{$\begin{array}{c}
        \cevald{e_d}{(n_1,n_2)\\
          t-t_0 \leq n_1 + n_2
        \end{array}}$}
    \AxiomC{\hspace{-2pt}$\begin{array}{c}
        \\
        e_d' \equiv
        \cwithinafter{n_2-\max(0,t-t_0-n_1)}{\max(0,n_1-t+t_0)}\end{array}$}
    \BinaryInfC{$\cupdate{D}{t_0}{t}{\begin{array}{l}\catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c}}
        {\\\catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d'}{c[x+t-t_0/x]}\end{array}}$}
    \DisplayProof{}
  
    \proofsep

    \AxiomC{$\cevald{e_d}{(n_1,n_2)}$}
    \AxiomC{$t-t_0 > n_1 + n_2$}
    \AxiomC{$\cupdate{D}{t_0+n_1+n_1+1}{t}{c_2}{r}$}
    \TrinaryInfC{$\cupdate{D}{t_0}{t}{\catomicp{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}{r}$}
    \DisplayProof{}
      
    \proofsep{}

    \AxiomC{$\begin{array}{c}
        \cevald{e_d}{(n_1,n_2)\\
          t-t_0 \leq n_1 + n_2
        \end{array}}$}
    \AxiomC{\hspace{-2pt}$\begin{array}{c}
        \\
        e_d' \equiv
        \cwithinafter{n_2-\max(0,t-t_0-n_1)}{\max(0,n_1-t+t_0)}\end{array}$}
    \BinaryInfC{$\cupdate{D}{t_0}{t}{\begin{array}{l}\catomicp{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}
        {\\\catomicp{\vec{a}}{k(\vec{x})}{x}{e}{e_d'}{c_1[x+t-t_0/x]}{c_2}\end{array}}$}
    \DisplayProof{}
  
    \proofsep

    \AxiomC{$\cupdate{D}{t_0}{t}{c_1}{r_1}$}
    \AxiomC{$\cupdate{D}{t_0}{t}{c_2}{r_2}$}
    \BinaryInfC{$\cupdate{D}{t_0}{t}{\canddefault}{r_1 \owedge r_2}$}
    \DisplayProof{}
    
    \proofsep{}

    \AxiomC{$\cupdate{D}{t_0}{t}{c_1}{r_1}$}
    \AxiomC{$\cupdate{D}{t_0}{t}{c_2}{r_2}$}
    \BinaryInfC{$\cupdate{D}{t_0}{t}{\cordefault}{r_1 \ovee r_2}$}
    \DisplayProof{}

    \proofsep{}

    \AxiomC{$\ceval{e}{\ctrue}$}
    \AxiomC{$\cupdate{D}{t_0}{t}{c_1}{r_1}$}
    \BinaryInfC{$\cupdate{D}{t_0}{t}{\cifthenelsedefault}{r_1}$}
    \DisplayProof{}
    \quad\quad
    \AxiomC{$\ceval{e}{\cfalse}$}
    \AxiomC{$\cupdate{D}{t_0}{t}{c_2}{r_2}$}
    \BinaryInfC{$\cupdate{D}{t_0}{t}{\cifthenelsedefault}{r_2}$}
    \DisplayProof{}

    \proofsep{}

    \AxiomC{$\ceval{\vec{e}}{\vec{d}}$}
    \AxiomC{$\cinstantiate{f}{\vec{x}}{\vec{y}} = c \in D$}
    \AxiomC{$\cupdate{D}{t_0}{t}{c[\vec{d}/\vec{x},\vec{a}/\vec{y}]\langle
        \vec{a}/\vec{y} \rangle}{r}$}
    \TrinaryInfC{$\cupdate{D}{t_0}{t}{\cinstantiate{f}{\vec{e}}{\vec{a}}}{r}$}
    \DisplayProof{}
    
    \proofsep{}
  \end{center}
  \begin{align*}
    r_1 \owedge r_2 &= \left\{
      \begin{array}{ll}
        \cand{c_1}{c_2}, & \mbox{if } r_1 = c_1 \mbox{ and } r_2 = c_2\\
        (t_1,B_1), & \mbox{if } r_1 = (t_1,B_1) \mbox{ and } r_2 = c_2\\
        (t_2,B_2), & \mbox{if } r_2 = (t_2,B_2) \mbox{ and } r_1 = c_1\\
        (t_1,B_1) \otimes (t_2,B_2), & \mbox{if } r_1 = (t_1,B_1) \mbox{
          and } r_2 = (t_2,B_2)
      \end{array}
    \right.\\
    r_1 \ovee r_2 &= \left\{
      \begin{array}{ll}
        \cor{c_1}{c_2}, & \mbox{if } r_1 = c_1 \mbox{ and } r_2 = c_2\\
        c_2, & \mbox{if } r_1 = (t_1,B_1) \mbox{ and } r_2 =  c_2\\
        c_1, & \mbox{if } r_2 = (t_2,B_2) \mbox{ and } r_1 = c_1\\
        (t_1,B_1) \oplus (t_2,B_2), & \mbox{if } r_1 = (t_1,B_1) \mbox{
          and } r_2 = (t_2,B_2)
      \end{array}\right.
  \end{align*}
  \caption{Updating of \csl{} clauses.}
  \label{fig:cupdate}
\end{figure}
A derivation, $\cupdate{D}{t_0}{t}{c}{r}$, means that $r$ is
``equivalent'' with $c$, if the deadlines in $c$ are relative to
$t_0$, and the current point in time is $t$. Since deadline
violations can occur, $r$ is either an updated clause, $c'$, or an
indication of a contract violation, $(t',B)$. The rules use lifted
versions of verdict conjunction, $\owedge$, and verdict disjunction,
$\ovee$, which are also defined in Figure \ref{fig:cupdate}.
The following lemma shows that the update relation is \emph{sound}.
\defthm{lemma}{lemma:cupdatesound}{Lemma}{Update is sound}{
  Let $c$ be a closed, well-typed clause, i.e.,
  $\ctclause{\Delta}{\emptyset}{\emptyset}{c}{A}$. Then for all
  guarded templates, $\ctcontext{D}{\Delta}$, $t_0,t \in \timeset$,
  and $\trace \in \traceset{A}$ with $\trace = \emptytrace \lor
  \tracestart(\trace) \geq t$, the following holds:
  \begin{align*}
    \mbox{if } \cupdate{D}{t_0}{t}{c}{c'} &\mbox{ then }
    \cdenclause{c}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}\trace =
    \cdenclause{c'}{\cdencontext{D}}{\emptyset}{\emptyset}{t}\trace\\
    \mbox{if }\cupdate{D}{t_0}{t}{c}{(t',B)} &\mbox{ then }
    \cdenclause{c}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}\trace =
    \lift{(t',B)} \mbox{ and } t' < t.
  \end{align*}
}
\begin{proof}
  The proof is included on page \pageref{proof:lemma:cupdatesound}.
  \qed
\end{proof}

\begin{lemma}[Update is total and
  deterministic]\label{lemma:cupdatedetermtotal}
  Let $c$ be a closed, well-typed clause, i.e.,
  $\ctclause{\Delta}{\emptyset}{\emptyset}{c}{A}$. Then for all
  guarded templates, $\ctcontext{D}{\Delta}$, and $t_0,t \in \timeset$, the
  update relation is total and deterministic, i.e., $\exists!
  r. \cupdate{D}{t_0}{t}{c}{r}$.
\end{lemma}
\begin{proof}
  The fact that the judgement is deterministic, follows immediately by
  inspecting the rules. The fact that the judgement is total, follows by
  induction on the derivation, $\cguarded{D}{\emptyset}{c}$ (which
  exists by Lemma \ref{lemma:guardednessbyconstruction}), but we omit
  the proof here.
  \qed
\end{proof}

We next define a small-step reduction relation for guarded, well-typed,
closed clauses, in Figure \ref{fig:cstep}.
\begin{figure}
  \fbox{$\cstep{D}{t}{c}{e}{r}$}
  \begin{center}
    \AxiomC{$\ceval{e[\vec{d}/\vec{x}]}{\ctrue}$}
    \AxiomC{$\cevald{e_d}{(n_1,n_2)}$}
    \AxiomC{$n_1 \leq t-t_0 \leq n_1 + n_2$}
    \TrinaryInfC{$\cstep{D}{t_0}{\catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c}}{\event{t}{a}{\emptychoice}{k(\vec{d})}}{c[\vec{d}/\vec{x},t-t_0/x]}$}
    \DisplayProof{}
  
    \proofsep

    \AxiomC{$\cevald{e_d}{(n_1,n_2)}$}
    \AxiomC{$t > t_0 + n_1 + n_2$}
    \BinaryInfC{$\cstep{D}{t_0}{\catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c}}{\event{t}{a'}{\choice}{k'(\vec{d}))}}{(t_0+n_1+n_2,\{a\})}$}
    \DisplayProof{}
  
    \proofsep

    \AxiomC{$a' \neq a \lor \choice \neq \emptychoice \lor k' \neq k
      \lor \ceval{e[\vec{d}/\vec{x}]}{\cfalse}$}
    \AxiomC{$\cevald{e_d}{(n_1,n_2)}$}
    \AxiomC{$t \leq t_0 + n_1 + n_2$}
    \TrinaryInfC{$\cstep{D}{t_0}{\catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c}}{\event{t}{a'}{\choice}{k'(\vec{d}))}}{(t,\{a'\})}$}
    \DisplayProof{}
  
    \proofsep

    \AxiomC{$\ceval{e[\vec{d}/\vec{x}]}{\ctrue}$}
    \AxiomC{$\cevald{e_d}{(n_1,n_2)}$}
    \AxiomC{$n_1 \leq t-t_0 \leq n_1 + n_2$}
    \TrinaryInfC{$\cstep{D}{t_0}{\catomicp{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}{\event{t}{a}{\emptychoice}{k(\vec{d}))}}{c_1[\vec{d}/\vec{x},t-t_0/x]}$}
    \DisplayProof{}
  
    \proofsep

    \AxiomC{$\cevald{e_d}{(n_1,n_2)}$}
    \AxiomC{$t > t_0 + n_1 + n_2$}
    \AxiomC{$\cstep{D}{t_0+n_1+n_2+1}{c_2}{\event{t}{a'}{\choice}{k'(\vec{d}))}}{r}$}
    \TrinaryInfC{$\cstep{D}{t_0}{\catomicp{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}{\event{t}{a'}{\choice}{k'(\vec{d}))}}{r}$}
    \DisplayProof{}
   
    \proofsep{}

    \AxiomC{$a' \neq a \lor \choice \neq \emptychoice \lor k' \neq k
      \lor \ceval{e[\vec{d}/\vec{x}]}{\cfalse}$}
    \AxiomC{$\cevald{e_d}{(n_1,n_2)}$}
    \AxiomC{$t \leq t_0 + n_1 + n_2$}
    \TrinaryInfC{$\cstep{D}{t_0}{\catomicp{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}{\event{t}{a'}{\choice}{k'(\vec{d}))}}{(t,\{a'\})}$}
    \DisplayProof{}
  
    \proofsep{}

    \AxiomC{$\begin{array}{c}
        \vspace{5pt}
        \cstep{D}{t_0}{c_i}{\event{t}{a}{\choice'}{k(\vec{d})}}{r_i}\\
        \cupdate{D}{t_0}{t+1}{c_j}{r_j}
      \end{array}$}
    \AxiomC{$
        (i,j,\choice') = \left\{\begin{array}{ll}
          (1,2,\choice''), &\mbox{if }= \choice = l.\choice''\\
          (2,1,\choice''), &\mbox{if }= \choice = r.\choice''\\
          (2,1,\emptychoice), &\mbox{if }= \choice = \emptychoice
        \end{array}\right.$}
    \BinaryInfC{$\cstep{D}{t_0}{\canddefault}{\event{t}{a}{\choice}{k(\vec{d})}}{r_1 \owedge r_2}$}
    \DisplayProof{}

    \proofsep{}

    \AxiomC{$\cstep{D}{t}{c_1}{e}{r_1}$}
    \AxiomC{$\cstep{D}{t}{c_2}{e}{r_2}$}
    \BinaryInfC{$\cstep{D}{t}{\cordefault}{e}{r_1 \ovee r_2}$}
    \DisplayProof{}

    \proofsep{}

    \AxiomC{$\ceval{e}{\ctrue}$}
    \AxiomC{$\cstep{D}{t}{c_1}{e}{r_1}$}
    \BinaryInfC{$\cstep{D}{t}{\cifthenelsedefault}{e}{r_1}$}
    \DisplayProof{}
    \quad\quad
    \AxiomC{$\ceval{e}{\cfalse}$}
    \AxiomC{$\cstep{D}{t}{c_2}{e}{r_2}$}
    \BinaryInfC{$\cstep{D}{}{\cifthenelsedefault}{e}{r_2}$}
    \DisplayProof{}

    \proofsep{}

    \AxiomC{$\ceval{\vec{e}}{\vec{d}}$}
    \AxiomC{$\cinstantiate{f}{\vec{x}}{\vec{y}} = c \in D$}
    \AxiomC{$\cstep{D}{t}{c[\vec{d}/\vec{x},\vec{a}/\vec{y}]\langle
        \vec{a}/\vec{y} \rangle}{e}{r}$}
    \TrinaryInfC{$\cstep{D}{t}{\cinstantiate{f}{\vec{e}}{\vec{a}}}{e}{r}$}
    \DisplayProof{}
  \end{center}
  \caption{Small-step semantics for \csl{} clauses.}
  \label{fig:cstep}
\end{figure}
A derivation, $\cstep{D}{t}{c}{e}{r}$, means that the
verdict of $r$ on a trace $\trace$ is ``equivalent'' with the verdict
of $c$ on the trace $e\trace$, where $\tracestart(e\trace) \geq
t$, and the deadlines of $c$ are relative to $t$. $r$ is either a
residual clause $c'$, or an indication of a 
contract violation, $(t',B)$. The stepping relation is defined using
the update relation from Figure \ref{fig:cupdate}, in order to check
for deadline expirations in clause conjunctions: since the event $e$
is always directed to either $c_1$ or $c_2$ in a contract conjunction,
we also need to check that no deadline has been violated in the other
clause in the meantime. The following lemma shows that the small-step
reduction relation is \emph{sound}.
\defthm{lemma}{lemma:cstepsound}{Lemma}{}{
  Let $c$ be a closed, well-typed clause, i.e.,
  $\ctclause{\Delta}{\emptyset}{\emptyset}{c}{A}$. Then for all
  guarded templates, $\ctcontext{D}{\Delta}$, $t_0 \in \timeset$, and
  $e\trace \in \traceset{A}$ with $\tracestart(e\trace) = t \geq t_0$,
  the following holds:
  \begin{align*}
    \mbox{if }\cstep{D}{t_0}{c}{e}{c'} &\mbox{ then }
    \cdenclause{c}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
    =
    \cdenclause{c'}{\cdencontext{D}}{\emptyset}{\emptyset}{(t+1)}{\trace}\\
    \mbox{if } \cstep{D}{t_0}{c}{e}{(t',B)} &\mbox{ then }
    \cdenclause{c}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)} =
    \lift{(t',B)} \mbox{ and } t' \leq t.
  \end{align*}
}
\begin{proof}
  The proof is included on page \pageref{proof:lemma:cstepsound}.
  \qed
\end{proof}

\begin{lemma}[Small-step semantics is total and
  deterministic]\label{lemma:cstepdetermtotal}
  Let $c$ be a closed, well-typed clause, i.e.,
  $\ctclause{\Delta}{\emptyset}{\emptyset}{c}{A}$. Then for all
  guarded templates, $\ctcontext{D}{\Delta}$, $t \in \timeset$,
  and $e \in \eventset{A}$, the small-step reduction relation is total
  and deterministic, i.e., $\exists! r. \cstep{D}{t}{c}{e}{r}$.
\end{lemma}
\begin{proof}
  The fact that the judgement is deterministic, follows immediately by
  inspecting the rules, and the fact that the update relation is 
  deterministic (Lemma \ref{lemma:cupdatedetermtotal}). The fact that
  the judgement is total, follows by induction on the derivation,
  $\cguarded{D}{\emptyset}{c}$ (which exists by Lemma
  \ref{lemma:guardednessbyconstruction}), and the fact that the update
  relation is total (Lemma \ref{lemma:cupdatedetermtotal}), but we omit 
  the proof here.
  \qed
\end{proof}

We are now almost ready to define a run-time monitoring algorithm for
\csl{}, but we need a syntactic characterization of
\emph{nullability}. Inspired by Andersen et
al. \cite{andersen06contracts}, we define such a relation in Figure
\ref{fig:cnullable}.
\begin{figure}[t]
  \fbox{$\cnullable{D}{c}$}
  \vspace{-20pt}
  \begin{center}
    \AxiomC{}
    \UnaryInfC{$\cnullable{D}{\cempty}$}
    \DisplayProof{}
    
    \proofsep
    
    \AxiomC{$\cnullable{D}{c_1}$}
    \AxiomC{$\cnullable{D}{c_2}$}
    \BinaryInfC{$\cnullable{D}{\canddefault}$}
    \DisplayProof{}
    
    \proofsep
    
    \AxiomC{$\cnullable{D}{c_1}$}
    \UnaryInfC{$\cnullable{D}{\cordefault}$}
    \DisplayProof{}
    \quad\quad
    \AxiomC{$\cnullable{D}{c_2}$}
    \UnaryInfC{$\cnullable{D}{\cordefault}$}
    \DisplayProof{}

    \proofsep

    \AxiomC{$\ceval{e}{\ctrue}$}
    \AxiomC{$\cnullable{D}{c_1}$}
    \BinaryInfC{$\cnullable{D}{\cifthenelsedefault}$}
    \DisplayProof{}
    \quad\quad
    \AxiomC{$\ceval{e}{\cfalse}$}
    \AxiomC{$\cnullable{D}{c_2}$}
    \BinaryInfC{$\cnullable{D}{\cifthenelsedefault}$}
    \DisplayProof{}
    
    \proofsep

    \AxiomC{$\ceval{\vec{e}}{\vec{d}}$}
    \AxiomC{$\cinstantiate{f}{\vec{x}}{\vec{y}} = c \in D$}
    \AxiomC{$\cnullable{D}{c[\vec{d}/\vec{x},\vec{a}/\vec{y}]\langle
        \vec{a}/\vec{y} \rangle}$}
    \TrinaryInfC{$\cnullable{D}{\cinstantiate{f}{\vec{e}}{\vec{a}}}$}
    \DisplayProof{}
  \end{center}
  \caption{Nullable clauses.}
  \label{fig:cnullable}
\end{figure}

\defthm{lemma}{lemma:cnullablesound}{Lemma}{}{
  Let $c$ be a closed, well-typed clause, i.e.,
  $\ctclause{\Delta}{\emptyset}{\emptyset}{c}{A}$. Then for all
  guarded templates, $\ctcontext{D}{\Delta}$, and $t \in \timeset$,
  \[
  \cnullable{D}{c} \mbox{ iff }
  \cdenclause{c}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\emptytrace} =
  \lift{\conforming}.
  \]
}
\begin{proof}
  The proof is included on page \pageref{proof:lemma:cnullablesound}.
  \qed
\end{proof}

We have now introduced all the auxiliary judgments, which will be used
in the (incremental) run-time monitoring algorithm for \csl{} clauses.
\begin{definition}[Run-time monitoring via residuation]
  Consider a well-typed, guarded set of contract templates,
  $\ctcontext{D}{\Delta}$. Then define the function,
  \[
  \mathit{rm} : \timeset \times \timeset \times \left\{c \mathbin{|}
    \ctclause{\Delta}{\emptyset}{\emptyset}{c}{A} \right\} \times
  \traceset{A} \to \verdictset{A}
  \uplus \{\inconclusive,\partialok\},
  \]
  by induction on the length of the trace:
  \begin{align*}
    \mathit{rm}(t_0,t,c,\emptytrace) &= \left\{
      \begin{array}{ll}
        \partialok, & \mbox{if } \cnullable{D}{c}\\
        (t',B), & \mbox{if } \cupdate{D}{t_0}{t+1}{c}{(t',B)}\\
        \inconclusive, & \mbox{otherwise}
      \end{array}
    \right.\\
    \mathit{rm}(t_0,t,c,e\trace) &= \left\{
      \begin{array}{ll}
        (t',B), & \mbox{if } \cstep{D}{t_0}{c}{e}{(t',B)}\\
        \mathit{rm}(\tracestart(e\trace)+1,t,c',\trace), & \mbox{if }
        \cstep{D}{t_0}{c}{e}{c'}
      \end{array}
    \right. .
  \end{align*}
\end{definition}

\begin{theorem}[Run-time monitoring via residuation]
  Let $c$ be a closed, well-typed clause, i.e.,
  $\ctclause{\Delta}{\emptyset}{\emptyset}{c}{A}$. Then for all
  guarded templates, $\ctcontext{D}{\Delta}$, and $t_0 \in \timeset$,
  $\rmf(\trace,t) = \mathrm{rm}(t_0,t,c,\trace)$ defines a run-time
  monitor for the contract $\cdencontract{\ccontract{D}{c}{t_0}}$.
\end{theorem}
\begin{proof}
  The proof is by induction on the length of $\trace$:
  \begin{itemize}
  \item[$\trace = \emptytrace$:] We must now show that
    \[
    \mathit{rm}(t_0,t,c,\emptytrace) = \left\{
      \begin{array}{ll}
        \conforming, & \mbox{ if } \forall \trace' \in
        \traceset{A}. \trace'_t = \emptytrace \Rightarrow
        \cdenclause{c}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace'}
        = \lift{\conforming}\\
        \partialok, & \mbox{ if } \exists \trace' \in
        \traceset{A}. \trace'_t = \emptytrace \land
        \cdenclause{c}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace'}
        \neq \lift{\conforming} \land\\
        &\hspace{12.5pt}
        \cdenclause{c}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\emptytrace}
        = \lift{\conforming}\\
        (t',B), & \mbox{ if }
        \cdenclause{c}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\emptytrace}
        = \lift{(t',B)} \land t' \leq t\\
        \inconclusive, & \mbox{ otherwise}
      \end{array}
    \right.
    \]
    Now, it is easy to show by induction on the derivation of
    $\cguarded{D}{\emptyset}{c}$ (which exists per Lemma
    \ref{lemma:guardednessbyconstruction}) that there is always a
    trace, $\trace' \in \traceset{A}$ with $\trace'_t = \emptytrace$,
    such that
    $\cdenclause{c}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace'}
    \neq \lift{\conforming}$. Consequently, the first case can never
    occur. So assume now that
    $\cdenclause{c}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\emptytrace}
    = \lift{\conforming}$. Then by Lemma \ref{lemma:cnullablesound} it
    follows that $\cnullable{D}{c}$, and therefore
    $\mathit{rm}(t_0,t,c,\emptytrace) = \partialok$, as required.

    Assume next that
    $\cdenclause{c}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\emptytrace}
    = \lift{(t',B)} \land t' \leq t$. It then follows from Lemma
    \ref{lemma:cupdatesound} and Lemma \ref{lemma:cupdatedetermtotal} that
    $\cupdate{D}{t_0}{t+1}{c}{(t',B)}$, and consequently
    $\mathit{rm}(t_0,t,c,\emptytrace) = (t',B)$, as required.

    In the final case we must have that
    $\mathit{rm}(t_0,t,c,\emptytrace) = \inconclusive$, since the
    nullability relation is sound and complete (Lemma
    \ref{lemma:cnullablesound}), and the update relation is
    deterministic (Lemma \ref{lemma:cupdatedetermtotal}).

    \item[$\trace = e\trace'$:] Now, the small-step reduction relation
      is total and deterministic, so there are two cases:
      \begin{itemize}
      \item[$\cstep{D}{t_0}{c}{e}{(t',B)}$:] It now follows from Lemma
        \ref{lemma:cstepsound} that
        $\cdenclause{c}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)} 
        = \lift{(t',B)} \land t' \leq t$, so the result follows by
        definition of run-time monitoring.
      \item[$\cstep{D}{t_0}{c}{e}{c'}$:] It now follows from Lemma
        \ref{lemma:cstepsound} that
        $\cdenclause{c}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
        =
        \cdenclause{c'}{\cdencontext{D}}{\emptyset}{\emptyset}{(\tracestart(e\trace)+1)}{\trace}$,
        so the result follows from the induction hypothesis, i.e.,
        $\mathit{rm}(\tracestart(e\trace)+1,t,c',\trace)$ is a
        run-time monitor for the contract
        $\cdencontract{\ccontract{D}{c'}{(\tracestart(e\trace)+1)}}$.
      \end{itemize}
    \end{itemize}
  \qed
\end{proof}

\section{Examples}\label{sec:cslexamples}
In this section we validate the applicability of \csl{} by encoding
various example contracts. We present each contract via an informal,
textual representation, together with the \csl{} specification, and
summarize the \csl{} features which are utilized in the encodings. We
already saw one example contract, namely the sales contract in Figure
\ref{fig:salescontract} (with \csl{} formalization on page
\pageref{csl:salescontract}). This example included conditional
commitments, relative and absolute deadlines, contrary-to-duty
obligations, and arithmetic expressions.
The next example we consider is a lease agreement, Figure
\ref{fig:lease}.
\begin{figure}[t]
  \begin{papercontract}
  \item The term of this lease is for \contractparam{term},
    beginning on \contractparam{begin date}. At the expiration of said term, the lease
    will automatically be renewed for a period of one month unless
    either party (Lessor or Lessee) notifies the other of its
    intention to terminate the lease at least one month before its
    expiration date.\label{clauseinfinite}
  \item The lease is for \contractparam{property}, which is provided
    by Lessor throughout the term.\label{clausecont}
  \item Lessee agrees to pay the amount of
    \contractparam{amount} per month, each payment due on the
    \contractparam{day} day of each month.\label{clauseinst}
  \end{papercontract}
  \caption{Lease agreement.}\label{fig:lease}
  % Source: http://www.aa.psu.edu/osl/housing/sample_lease.pdf
\end{figure}
This contract is interesting, because it is potentially infinite,
i.e., the expiration of the lease agreement is not stipulated at the
time of contract signing, but rather it is determined by one of the
participants \emph{eventually} requesting a termination. The \csl{}
specification is presented below:
\begin{lstlisting}[language=csl]
letrec
lease(property, leaseStart, leasePeriod, leasePeriods,
      amount, payDeadline, terminationRequested)<lessor, lessee> =
 if leasePeriods <= 0 && terminationRequested then
   // Contract has expired
   empty
 else
   <lessee> Payment(a,r)
    where a == amount andalso
          r == lessor
    due within payDeadline after leaseStart
   and
   <lessor> Lease(p,d,r)
    where p == property andalso
          d == leasePeriod andalso
          r == lessee
    due immediately after leaseStart
    then
      if terminationRequested then
        // A termination has previously been requested
        lease(property, leasePeriod, leasePeriod, leasePeriods - 1,
              amount, payDeadline, true)<lessor, lessee>
      else
        if <lessor,lessee> ReqTermination @ t
            due within leasePeriod
        then
          // Lessor or lessee requests termination, so the lease
          // should end after the minimum of 1 lease period and the
          // remaining amount of lease periods
          lease(property, leasePeriod -- t, leasePeriod,
                min(1,leasePeriods - 1),
                amount, payDeadline, true)<lessor, lessee>
        else
          // Nobody requests termination
          lease(property, 0D, leasePeriod, leasePeriods - 1,
                amount, payDeadline, false)<lessor, lessee>
in
lease("House", 0D, 1M, 6, 2000, 1W, false)<Landlord, Tenant>
starting 2010-07-01
\end{lstlisting}
In the last line, the lease template is instantiated with some example
values, which represent the leasing (renting) of a house for a minimum
of 6 months, with a monthly fee of 2000 USD, and payment due within
the first week of each month. As mentioned above, the lease agreement
is potentially infinite --- in the formalization this is evident from
the fact that it is only the permission of lessor/lessee in each month to
request a termination that can terminate the contract. Besides being
potentially infinite, the example shows how freeze variables can be
utilized: in order to specify the next lease period relative to the
time of a request for termination, we need to know how much time has
elapsed before the request was made. Finally, the example
illustrates a permission with multiple agents (i.e., requesting
termination).

The next contract we consider, Figure \ref{fig:salesdiff}, is a
variant of the sales agreement from Figure \ref{fig:salescontract}.
\begin{figure}[t]
  \begin{papercontract}
  \item Seller agrees to transfer and deliver to Buyer, on
    or before \contractparam{delivery date}, the below-described goods:
    \contractparam{goods}, but possibly in multiple batches.
  \item Buyer agrees to accept the goods and pay for
    them according to the terms further set out below.
  \item Buyer agrees to pay for the goods either (1) in
    full on receipt, or (2) half upon receipt, with the remainder (plus an
    additional 5\%) due within \contractparam{days} days.
  \end{papercontract}
  \caption{Sales contract with different payment options.}\label{fig:salesdiff}
\end{figure}
Compared with the contract from Figure \ref{fig:salescontract}, the
Seller is now allowed to deliver the set of goods in multiple batches,
and furthermore, the Buyer can choose from different payment
options. The \csl{} formalization is presented below:
\begin{lstlisting}[language=csl]
letrec
sale'(deliveryDeadline, goods, amount, latePaymentDeadline)<buyer, seller> =
 if goods == [] then
   // All goods have been delivered, so Buyer most pay
   <buyer> Payment(a,r)
    where a == payment andalso
          r == seller
    due immediately
   or
   <buyer> Payment(a,r)
    where a == payment / 2 andalso
          r == seller
    due immediately
    then
      <buyer> Payment(a,r)
       where a == 1.05 * (amount / 2) andalso
             r == seller
       due within latePaymentDeadline
 else
   // Goods remain to be delivered, possibly in multiple batches
   <seller> TransferAndDeliver(g,r) @ t
    where g <= goods andalso
          [] < g andalso
          r == buyer
    due within deliveryDeadline
    then
      sale'(deliveryDeadline -- t, goods - g, amount, latePaymentDeadline)
           <buyer, seller>
in
sale'(14D, ["iPad","MacBook Pro", "iPhone 4"], 6000, 14D)<"Tom", "Apple">
starting 2010-07-01
\end{lstlisting}
Here we assume a signature with $\tp(\mbox{TransferAndDeliver}) =
(\mbox{Goods},\ctpagent)$, where $\dendom{\mbox{Goods}} =
\dendom{\mbox{Good}}^*$ and $\dendom{\mbox{Good}} =
\mbox{String}$, and we assume that the expression language has been extended to
include operations on lists. The encoding illustrates contract disjunction
(choice), and it shows how recursive template definitions make it
possible to dynamically calculate the remaining goods to be
delivered.

The next contract we consider is an installment sale, Figure
\ref{fig:installment}.
\begin{figure}[t]
\begin{papercontract}
    \item Seller agrees to transfer and deliver to Buyer, on
    or before \contractparam{delivery date}, the below-described
    goods: \contractparam{goods}.
  \item Buyer agrees to pay to Seller the total sum
    \contractparam{sum}, in the manner following:
  \item The sum of \contractparam{prepayment}, receipt of which is
    hereby acknowledged, and \contractparam{closing payment} is to be
    paid at closing, and the balance of \contractparam{balance} shall
    be paid as follows:
  \item \contractparam{installment} or more per month on the first day
    of each and every month hereafter commencing on
    \contractparam{first month}, and continuing until the entire
    balance, including both principal and interest, shall be paid in
    full; provided, however, that the entire balance due plus accrued
    interest and any other amounts due hereunder shall be paid in full
    on or before \contractparam{months} months.\label{clausebalance}
  \item Monthly payments shall include both principle and interest
    with interest at the rate of \contractparam{rate}\%  per annum,
    computed monthly on the remaining balance from time to time
    unpaid.  Monthly payments shall be applied first to interest and
    any other amounts due hereunder and the balance to principle.
    Buyer shall have the privilege of prepayment at any time without
    penalty.
  \end{papercontract}
  \caption{Installment sales.}\label{fig:installment}
  % Source: http://www.crs.com/images/installment_contract.doc
\end{figure}
The \csl{} formalization is presented below, but we only formalize the
payment paragraphs (Paragraph 4 and 5), since the other paragraphs are
straightforward (similar to what we have seen in previous examples):
\begin{lstlisting}[language=csl]
letrec
installments(balance, installment, payDeadline, start, end, frequency,
             rate, closingPayment, seller)<buyer> =
 if balance <= 0 then
   // Balance has been fully paid, so closing payment is due
   <buyer> Payment(a,r)
    where a == closingPayment andalso
          r == seller
    due within end
 else
 if end <= start then
   // The closing day has been reached, so buyer must pay
   // remaining balance + closing payment
   <buyer> Payment(a,r)
    where a == balance + closingPayment andalso
          r == seller
    due within end
 else
   // The closing day has not been reached, so buyer must 
   // pay a normal installment
   <buyer> Payment(a,r) @ t
    where a >= min(balance,installment) andalso
          a <= balance andalso
          r == seller
    due within payDeadline after start
   then
   installments((1 + rate) * (balance - a), installment,
                payDeadline, frequency -- t, end -- frequency,
                frequency, rate, closingPayment, seller)<buyer>
in
installments(10000, 1000, 1W, 0D, 12M, 1M, 0.1, 500, Seller)<Buyer>
starting 2010-07-01
\end{lstlisting}
Note that the seller has no obligations in the payment of
installments, and therefore seller is not passed as an agent parameter
to the template definition, but rather as an ordinary
parameter. Attempting to pass seller as an agent parameter would make
the template ill-typed, due to the relevance typing of agents. The
template is instantiated with example values, resembling the payment
of 10.000 USD over 1 year, with a monthly installment of at least 1000
USD (payment due within one week of each month), a monthly interest
rate of 10\%, and a closing payment of 500 USD (plus any remaining
balance). The formalization shows how in-place arithmetic expressions
are needed to calculate the remaining balance in each month, based on
the old balance, what is being paid, and the interest rate.

Next we consider a master sales agreement, Figure \ref{fig:master},
and the corresponding \csl{} formalization:
\begin{figure}[t]
  \begin{papercontract}
  \item The master agreement between Vendor and Customer is for 1000
    Printers, with unit price 100 USD, and is valid in the period
    between 1st of July 2010 and 1st of July 2011.
  \item If the Customer requests a set of goods according to above,
    Vendor has to transfer and deliver the goods before the maximum
    of (i) 14 days, or (ii) the number of ordered goods divided by ten
    days.
  \item After transferring and delivering the goods, the Vendor must
    invoice the Customer within 1 month, after which the goods must be
    paid for by Customer within 14 days.
  \end{papercontract}
  \caption{Master sales agreement.}\label{fig:master}
\end{figure}
\begin{lstlisting}[language=csl]
letrec
master(goods, amount, terminationDeadline, payment,
       invoiceDeadline, paymentDeadline)<vendor, customer> =
 if amount == 0 then
   // No more goods in the master agreement, so it is terminated
   empty
 else
   if <customer> Request(n,g,r) @ t
       where 0 < n andalso
             n <= amount andalso
             g == goods andalso
             r == vendor
       due within terminationDeadline
   then
     sale(dup(n,goods), n*amount, max(14D,amount*24*60*60/10),
          invoiceDeadline, paymentDeadline)<vendor, customer>
     and
     master(goods, amount - n, terminationDeadline -- t, payment,
            invoiceDeadline, paymentDeadline)<vendor, customer>

sale(goods, payment, deliveryDeadline, invoiceDeadline, paymentDeadline)
    <seller, buyer> =
 <seller> TransferAndDeliver(g,r)
  where g == goods andalso
        r == buyer
  due within deliveryDeadline
 then
   if <seller> IssueInvoice(r)
       where r == seller
       due within invoiceDeadline
   then
     <buyer> Payment(a,r)
      where a == payment andalso
            r == seller
      due within paymentDeadline
in
master("Printer", 1000, 1Y, 100, 14D, 14D)<Vendor, Customer>
starting 2010-07-01
\end{lstlisting}
As in a previous example, we assume that the expression language is
extended to include lists --- specifically we assume the existence of
a function \texttt{dup}, where \texttt{dup(n,v)} constructs a list
with $n$ copies of the value $v$. The example above illustrates the
modularity of \csl{}, in the form of the template \texttt{sale}, which
is used to define the template \texttt{master}. If we want another
variant of the master agreement, in which the conditions in each sale
are different, we simply only have to change the \texttt{sale}
definition, and the \texttt{master} template remains unchanged.

The next example we consider, is a legal service agreement
\cite{andersen06contracts}, Figure \ref{fig:legalservice}, with \csl{}
specification presented below:
\begin{figure}[t]
  \begin{papercontract}
  \item The attorney shall provide, on a non-exclusive basis, legal
    services up to \contractparam{hours} hours per month, and
    furthermore provide services in excess of \contractparam{hours}
    hours upon agreement.
  \item In consideration hereof, the company shall pay a monthly fee of
    \contractparam{fee} USD before the 8th day of the following month and
    \contractparam{rate} per hour for any services in excess of
    \contractparam{hours} hours 40 days after receiving an invoice.
  \end{papercontract}
  \caption{Legal service agreement.}\label{fig:legalservice}
  % Source \cite{andersen06contracts}
\end{figure}

\begin{lstlisting}[language=csl]
letrec
legal(service, hours, fee, rate, start, frequency, paymentDeadline,
      invoiceDeadline, excessPaymentDeadline)<attorney, company> =
 <company> Payment(a,r)
  where a == fee andalso
        r == attorney
  due within paymentDeadline after start
 and
 <attorney> ProvideService(s, h, r) @ t
  where s == service  andalso
        r == company
  due within frequency after start
 then
   legal(service, hours, fee, rate, (start + frequency) -- t,
         paymentDeadline, invoiceDeadline, excessPaymentDeadline)
        <attorney, company>
   and
   if h > hours then
     if <attorney> IssueInvoice(r)
         where r == company
         due within invoiceDeadline
     then
       <company> Payment(a,r)
        where a == (h - hours) * rate andalso
              r == att
        due within excessPaymentDeadline
   else
     empty
in
legal("legal service", 50, 8000, 150, 0D, 1M, 1M+8D, 40D)<Attorney, Company>
starting 2010-07-01
\end{lstlisting}
Compared with the previous examples, the example above contains
nothing conceptually new. However, it shows that \csl{} can encode the
example contract by Andersen et al. \cite{andersen06contracts}.

The last example we consider, Figure \ref{fig:bandwidth}, is a
bandwidth policy, taken from the paper by Kyas et
al. \cite{kyas08clrm}.
\begin{figure}[t]
  \begin{papercontract}
  \item If the Client exceeds the bandwidth limit then (s)he must pay
    \contractparam{price} immediately, or (s)he must delay the payment
    and notify the Provider by sending an e-mail. If in breach of the
    above (s)he must pay double.
  \end{papercontract}
  \caption{Bandwidth policy.}\label{fig:bandwidth}
  % Source: $\mathcal{CL}$ paper.
\end{figure}
The policy contains no qualitative deadlines, since such temporal
constraints are not handled by the contract language of Kyas et
al., however, in the formalization below we include
deadlines as well:
\begin{lstlisting}[language=csl]
bwpolicy(validityPeriod, price, notificationDeadline,
         paymentDeadline, latePaymentDeadline)<client, provider> =
 if <client> ExceedBandwidth @ t
     due within validityPeriod
 then
   (<client> Payment(a)
     where a == price
     due immediately
    or
    (<client> SendEmail
      due within notificationDeadline
     and
     <client> Payment(a)
      where a == price
      due within paymentDeadline)
    or
    <client> Payment(a)
     where a == 2 * price
     due within latePaymentDeadline)
   and
   bwpolicy(validityPeriod -- t, price, notificationDeadline,
            paymentDeadline, latePaymentDeadline)<client, provider>)
\end{lstlisting}

\section{Conclusion}\label{sec:conclusion}
In this paper we have presented a novel, trace-based model for
multi-party contracts, which distinguishes itself from previous work
by deterministically assigning blame to contract participants in case
of contract violations. We have analyzed the implications
deterministic blame assignment has for contract compositionality, and
we have constructed a contract specification language, \csl{},
equipped with a formal semantics in terms of the trace-based model. \csl{}
overcomes the limitations of previous contract languages by supporting
\begin{inparaenum}[(a)]
\item (history sensitive and conditional) commitments,
\item parametrized contract templates,
\item relative and absolute temporal constraints,
\item contrary-to-duty obligations,
\item potentially infinite contracts,
\item arithmetic expressions, and
\item blame-assignment.
\end{inparaenum}
Furthermore, we have presented an algorithm for run-time monitoring
contracts written in \csl{}, which lends itself amenable to run-time
analysis of contracts as well, due to the reduction style semantics of
the algorithm.

\subsection{Future work}\label{sec:futurework}
Our work is set in the context of the research project
3gERP\footnote{3rd generation Enterprise Resource Planning,
  \url{http://www.3gerp.org}.}, in which the aim is to develop the
theoretical foundations for ``next generation'' enterprise resource
planning (ERP) systems. The working thesis in the 3gERP project is
that an event-driven architecture is well-suited for such systems
\cite{henglein09poets}, and one of the core features of said
architecture are executable/monitorable contracts. The end goal of the
3gERP project is to demonstrate a prototype implementation of the
event-driven architecture, and our first direction for future work is
consequently a prototype implementation of \csl{}.

The second direction for future work --- which is currently being
investigated --- is to extend the abstract contract model to include
nondeterministic contracts as well. Still, only deterministic
contracts will be considered ``good'', but instead of restricting
\csl{} to deterministic contracts, it may be possible to extend the
language with potentially nondeterministic operators, in such a way
that determinism of \csl{} contracts becomes a decision problem. Such
extension will open up for the possibility of encoding paper
contracts, where it is not clear how to do so using only a
deterministic language, and ask the decision procedure if the contract
is deterministic.

The final major direction for future work is \emph{contract
  analysis}. Peyton-Jones and Eber \cite{jones03contracts} have shown
how to perform valuation of financial contracts written in a
combinator language, and besides the ability to perform run-time
monitoring, we see the ability to perform syntax based contract
analysis as the most valuable gain to stand from a formal
specification (the above mentioned problem of deciding determinism is
also an analysis). One of the strengths of \csl{} is that is admits
\emph{what if analysis} \cite{tan01survey}: any syntax based analysis
that can be performed on a clause written in \csl{}, can automatically
be applied to a hypothetical setting, i.e., under the assumption that
some events will take place. This is due to the reduction semantics
of the run-time monitoring algorithm, which transforms an (initial)
clause into a residual clause based on an event (cf., section
\ref{sec:runtimemonitoringcsl}). Examples of contract analyses which could be
interesting to consider are:
\begin{itemize}
\item Outstanding obligations (w.r.t. a particular agent).
\item Satisfiability (w.r.t. a particular agent).
\item Resource analysis (w.r.t. a particular agent).
\item Contract refinement.
\end{itemize}
The first analysis is relatively straightforward to implement, but the
second will in general be undecidable due to \csl{}'s full
recursion. However, by construction all deadlines can always be
fulfilled, so it may be possible to restrict the set of expressions
that can be used in the \texttt{where} clause of an atomic obligation,
in order to syntactically guarantee that a clause can always be
satisfied. By resource analysis we mean a (probabilistic) analysis of
the actions that a particular agent is expected to perform, the time
constraints involved (time is also a resource), and the
actions expected by other parties of the contract. As an example, the
expected \emph{input} from Buyer in the example contract from Figure
\ref{fig:salescontract} is 500 USD, and the expected \emph{outcome} is
one iPad. \fxfatal{Game theory, optimal solution w.r.t. an agent.}

Contract refinement means considering a partial order on
contracts, $\contract_1 \sqsubseteq \contract_2$, with the intuition
that $\contract_2$ is at least as forgiving as $\contract_1$, similar
to the contract relation of Back and von Wright
\cite{back00cgr}. However, since we deal with a model of contracts in
which blame is assigned in case of violations, the relation by Back
and von Wright cannot be used directly. For \csl{}
clauses it could be interesting to consider the possibility of
syntactically deciding refinement of one contract by another, for
instance in order to verify that an updated contract description is
not more demanding (or the other way around, not more forgiving) than
an old description. Being able to decide contract refinement for (a
fragment of) \csl{} clauses will also automatically provide an
algorithm for deciding equivalence of contracts, as $\contract_1
\sqsubseteq \contract_2 \land \contract_2 \sqsubseteq \contract_1
\mbox{ iff } \contract_1 = \contract_2$.

\subsection{Related work}\label{sec:relatedwork}
Most existing work on contract formalisms roughly fall into three
categories: (deontic) logic based formalisms
\cite{lee88electroniccontracting,boulmakoul02integratedcontract}, 
\emph{event-condition-action} \cite{bernstein01db} based formalisms
\cite{goodchild00b2b,governatori06formalbcl},
and action/trace based formalisms
\cite{andersen06contracts,prisacariu07cl}. (We have not included
follow-up papers here.) However, we have also encountered formalisms
based on combinators \cite{jones03contracts}, defeasible reasoning
\cite{tan00incas,governatori09drcontract}, 
commitment graphs \cite{xu04multipartycontracts}, finite state
machines \cite{molina04runtimemonitoring}, and more informal
approaches \cite{crf04cel,oren09towards}.

Compared with our work, existing approaches focus either on a
specification language/logic for writing contracts 
\cite{lee88electroniccontracting,boulmakoul02integratedcontract,goodchild00b2b,governatori06formalbcl,andersen06contracts,prisacariu07cl,jones03contracts,tan00incas,governatori09drcontract,crf04cel},
or a more abstract model for contracts
\cite{xu04multipartycontracts,oren09towards,molina04runtimemonitoring},
but none consider both. Of the existing approaches, only Xu
\cite{xu04multipartycontracts} considers blame assignment, but there
is no account for composing contracts nor a language for specifying
contracts. Only very few formalisms come with a clear, formal semantics
\cite{prisacariu07cl,andersen06contracts}, which is otherwise crucial
if the formalized contracts are to be used directly as legally binding
agreements --- and in that case deterministic blame assignment is ever
more crucial.

History sensitive contracts, i.e., contracts in which the exact
content of commitments can depend on what has happened in the past,
are supported by few formalisms
\cite{governatori06formalbcl,andersen06contracts}, whereas conditional
commitments are handled by most formalisms
\cite{lee88electroniccontracting,governatori06formalbcl,goodchild00b2b,prisacariu07cl,boulmakoul02integratedcontract,oren09towards}. Only
the language of Andersen et al. \cite{andersen06contracts} has direct
support for contract templates, however it should not be difficult to add
to the other formalisms. Relative temporal constraints, i.e.,
sequential dependencies, are supported in most formalisms
\cite{lee88electroniccontracting,xu04multipartycontracts,governatori06formalbcl,goodchild00b2b,andersen06contracts,molina04runtimemonitoring,oren09towards},
and also most formalisms support absolute temporal constrains
\cite{lee88electroniccontracting,governatori06formalbcl,goodchild00b2b,andersen06contracts,boulmakoul02integratedcontract,molina04runtimemonitoring}.
Contrary-to-duty/reparation clauses are included as primitives in some
contract languages/models
\cite{governatori06formalbcl,prisacariu07cl,boulmakoul02integratedcontract,oren09towards},
while potentially infinite contracts are treated by Andersen et
al. \cite{andersen06contracts} and Prisacariu and Schneider
\cite{prisacariu07cl}.

The ability to run-time monitor contracts is recognized by most
authors as crucial
\cite{xu04multipartycontracts,governatori06formalbcl,goodchild00b2b,prisacariu07cl,andersen06contracts,molina04runtimemonitoring},
but since most existing work lack a formal fundament, it is difficult
to compare the existing approaches to run-time monitoring of
contracts. However, Andersen et al. \cite{andersen06contracts} show
how contract monitoring can be performed via \emph{residuation} (which
inspired our algorithm), and Kyas et al. \cite{kyas08clrm} show how
finite state machines can be derived from contract specifications in
the language of Prisacariu and Schneider \cite{prisacariu07cl}. 

\subsubsection{Acknowledgements}
The author wishes to thank Dr. Felix Klaedtke and Dr. Eugen Zalinescu
for numerous and enlightening discussions. In addition the author
expresses his gratitude to Prof. Dr. David Basin for the invitation to
visit the Information Security group at ETH Zürich.

% -- Bibliography
\phantomsection
\addcontentsline{toc}{section}{\bibname}
\bibliographystyle{splncs}
\bibliography{tracemodel}

\newpage
\section{Proofs}
\refthm{lemma:cdenclausewelldefined}
\begin{proof}
  The proof is by induction on the typing derivation, but we need to
  show the more general claim that if
  $\ctclause{\Delta}{\Lambda}{\Gamma}{c}{A}$ then
  \[
  \cdenclause{c}{}{}{}{}{} : \dendom{\Delta} \to (\Pi_{\lambda \in 
    \dendom{\Lambda'}} (\dendom{\Gamma} \to C_{A' \cup
    \cod{\lambda}})),
  \]
  is well-defined for all $\Lambda' \supseteq \Lambda$ and $A' \supseteq A$. The only
  interesting cases are $c \equiv \canddefault$ and $c \equiv
  \cordefault$:
  \begin{itemize}[]\itemsep=5pt
  \item \fbox{\scriptsize \AxiomC{$\ctclause{\Delta}{\Lambda_1}{\Gamma}{c_1}{A_1}$}
      \AxiomC{$\ctclause{\Delta}{\Lambda_2}{\Gamma}{c_2}{A_2}$}
      \BinaryInfC{$\ctclause{\Delta}{\Lambda_1 \cup
          \Lambda_2}{\Gamma}{\canddefault}{A_1 \cup A_2}$}
      \DisplayProof{}}

    We get from the induction hypothesis that
    \begin{align*}
      \cdenclause{c_1}{}{}{}{}{} &: \dendom{\Delta} \to (\Pi_{\lambda
        \in \dendom{\Lambda'}} (\dendom{\Gamma} \to C_{A' \cup
        \cod{\lambda}}))\\
      \cdenclause{c_2}{}{}{}{}{} &: \dendom{\Delta} \to (\Pi_{\lambda
        \in \dendom{\Lambda'}} (\dendom{\Gamma} \to C_{A' \cup
        \cod{\lambda}}))
   \end{align*}
   for $\Lambda' \supseteq \Lambda_1 \cup \Lambda_2$ and $A' \supseteq
   A_1 \cup A_2$, and consequently the result follows from the
   definition of $\otimes_\bot$.

 \item \fbox{\scriptsize \AxiomC{$|\Lambda| + |A| = 1$}
     \AxiomC{$\ctclause{\Delta}{\Lambda}{\Gamma}{c_1}{A}$}
     \AxiomC{$\ctclause{\Delta}{\Lambda}{\Gamma}{c_2}{A}$}
     \TrinaryInfC{$\ctclause{\Delta}{\Lambda}{\Gamma}{\cordefault}{A}$}
     \DisplayProof{}}

   We get from the induction hypothesis that
    \begin{align*}
      \cdenclause{c_1}{}{}{}{}{} &: \dendom{\Delta} \to (\Pi_{\lambda
        \in \dendom{\Lambda'}} (\dendom{\Gamma} \to C_{A' \cup
        \cod{\lambda}}))\\
      \cdenclause{c_2}{}{}{}{}{} &: \dendom{\Delta} \to (\Pi_{\lambda
        \in \dendom{\Lambda'}} (\dendom{\Gamma} \to C_{A' \cup
        \cod{\lambda}}))
   \end{align*}
   for $\Lambda' \supseteq \Lambda$ and $A' \supseteq A$. We must now
   show that we can never have a situation where
   $\cdenclause{c_1}{\delta}{\lambda}{\gamma}{t_0}{\trace} = (t,B_1)$ and
   $\cdenclause{c_2}{\delta}{\lambda}{\gamma}{t_0}{\trace} = (t,B_2)$,
   where $B_1 \neq B_2$, because then $\oplus$ is always
   well-defined. There are two cases:
   \begin{itemize}
     \item $A = \{a\} \land \Lambda = \emptyset$. Now, since
       $\ctclause{\Delta}{\Lambda}{\Gamma}{c_1}{A}$, it follows that
       either $B_1 = \{a\}$ or $B_1 = \{a'\} \land
       \event{t}{a'}{\choice}{k(\vec{d})} \in \trace$ (formally a
       proof by induction on the typing derivation of $c_1$),
       corresponding to the cases where $a$ misses a deadline or $a'$
       performs an illegal event. Similar,
       either $B_2 = \{a\}$ or $B_2 = \{a'\} \land
       \event{t}{a'}{\choice}{k(\vec{d})} \in \trace$. So we need to
       check that $B_1 = B_2$. But it is easy to check (by induction
       on the typing derivation of $\cordefault$) that if $B_2 =
       \{a'\}$ then also necessarily $B_1 = \{a'\}$. Hence the result
       follows.
     \item $A = \emptyset \land \Lambda = \{x\}$. Similar to the case
       above, but now either $B_1,B_2 = \{\lambda(x)\}$ or $B_1,B_2 =
       \{a'\} \land \event{t}{a'}{\choice}{k(\vec{d})} \in \trace$.
     \end{itemize}
   \end{itemize}
   \qed
\end{proof}

\refthm{lemma:cdenclausecont}
\begin{proof}
  We must show that $\cdenclause{c}{}{}{}{}{}$ is monotone, i.e.,
  $\delta \sqsubseteq \delta' \Rightarrow \cdenclause{c}{\delta}{}{}{}{}
  \sqsubseteq \cdenclause{c}{\delta'}{}{}{}{}$, and that
  $\cdenclause{c}{}{}{}{}{}$ preserves limits, i.e.,
  $\cdenclause{c}{(\bigsqcup_i \delta_i)}{}{}{}{} = \bigsqcup_i
  \cdenclause{c}{\delta_i}{}{}{}{}$.

  ~

  \emph{Monotonicity:}
  Now assume that $\delta \sqsubseteq \delta'$. By definition of the
  point-wise ordering, we must show that
  $\cdenclause{c}{\delta}{\lambda}{\gamma}{t_0}{\trace} \leq
  \cdenclause{c}{\delta'}{\lambda}{\gamma}{t_0}{\trace}$, for all
  $\lambda \in \dendom{\Lambda}$, $\gamma \in \dendom{\Gamma}$, $t_0
  \in \timeset$, and $\trace \in \traceset{A \cup \cod{\lambda}}$,
  where $\leq$ is the ordering on $\verdictsetlift{A \cup
    \cod{\lambda}}$, i.e., $v_1 \leq v_2 \mbox{ iff } v_1 = \bot \lor
  v_1 = v_2$. We proceed by structural induction on $c$:
  \begin{itemize}\itemsep=5pt
  \item[$c \equiv \cempty$:]
    Follows directly, since
    $\cdenclause{\cempty}{\delta}{\lambda}{\gamma}{t_0}{\trace} =
    \cdenclause{\cempty}{\delta'}{\lambda}{\gamma}{t_0}{\trace}$.
  \item[$c \equiv \catomic{e_a}{k(\vec{x})}{x}{e}{e_d}{c'}$:]
    There are three cases in the definition, but only case (a) is
    interesting, since $\delta/\delta'$ are not used in the other two cases.
    So assume that $\trace =
    \event{t}{\cdenaexp{e_a}{\lambda}}{\emptychoice}{k(\vec{d})}\trace'$
    and that $\cdenclause{c}{\delta}{\lambda}{\gamma}{t_0}{\trace} =
    \cdenclause{c'}{\delta}{\lambda}{\gamma[\vec{x} \mapsto \vec{d}, x
      \mapsto t - t_0]}{(t+1)}{\trace'}$. Now since the case tests in
    the definitions do not depend on $\delta/\delta'$ we must also
    have that $\cdenclause{c}{\delta'}{\lambda}{\gamma}{t_0}{\trace} =
    \cdenclause{c'}{\delta'}{\lambda}{\gamma[\vec{x} \mapsto \vec{d}, x
      \mapsto t - t_0]}{(t+1)}{\trace'}$. But then the
    result follows from the induction hypothesis ($c'$ is a proper
    sub clause of $c$).
  \item[$c \equiv \catomicp{\vec{e_a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}$:]
    There are three cases in the definition, but only case (a') and (b') are
    interesting, since $\delta/\delta'$ are not used in case (c').
    \begin{itemize}
      \item[(a')] Identical with case (a) above.
      \item[(b')] Now, $\trace = \emptytrace$ or $\tracestart(\trace)
        > t_2$, $\cdendexp{e_d}{\gamma}{t_0} = [t_1;t_2]$, and
        $\cdenclause{c}{\delta}{\lambda}{\gamma}{t_0}{\trace} =
        \cdenclause{c_2}{\delta}{\lambda}{\gamma}{(t_2+1)}{\trace}$. Then
        since the case tests in the definition do not depend on
        $\delta/\delta'$, we must also have that
        $\cdenclause{c}{\delta'}{\lambda}{\gamma}{t_0}{\trace} = 
        \cdenclause{c_2}{\delta'}{\lambda}{\gamma}{(t_2+1)}{\trace}$. But then the
        result follows from the induction hypothesis ($c_2$ is a proper
        sub clause of $c$).
      \end{itemize}
  \item[$c \equiv \canddefault$:]
    By definition of $\otimes_\bot$, we have that (where
    $\tracesplit(\trace) = (\trace_1,\trace_2)$)
    \begin{scriptsize}
      \begin{align*}
        \cdenclause{\canddefault}{\delta}{\lambda}{\gamma}{t_0}{\trace} &=
        \left\{ \begin{array}{ll}
            \bot, &\mbox{if }
            \cdenclause{c_1}{\delta}{\lambda}{\gamma}{t_0}{\trace_1} =
            \bot \lor
            \cdenclause{c_2}{\delta}{\lambda}{\gamma}{t_0}{\trace_2} =
            \bot\\
            \lift{v_1 \otimes v_2}, &\mbox{if }
            \cdenclause{c_1}{\delta}{\lambda}{\gamma}{t_0}{\trace_1} = 
            \lift{v_1} \land
            \cdenclause{c_2}{\delta}{\lambda}{\gamma}{t_0}{\trace_2} =
            \lift{v_2}
          \end{array}\right.\\
        \cdenclause{\canddefault}{\delta'}{\lambda}{\gamma}{t_0}{\trace} &=
        \left\{ \begin{array}{ll}
            \bot, &\mbox{if }
            \cdenclause{c_1}{\delta'}{\lambda}{\gamma}{t_0}{\trace_1} =
            \bot \lor
            \cdenclause{c_2}{\delta'}{\lambda}{\gamma}{t_0}{\trace_2} =
            \bot\\
            \lift{v_1 \otimes v_2}, &\mbox{if }
            \cdenclause{c_1}{\delta'}{\lambda}{\gamma}{t_0}{\trace_1} = 
            \lift{v_1} \land
            \cdenclause{c_2}{\delta'}{\lambda}{\gamma}{t_0}{\trace_2} =
            \lift{v_2}
          \end{array}\right. .
      \end{align*}
    \end{scriptsize}
    Now, if either
    $\cdenclause{c_1}{\delta}{\lambda}{\gamma}{t_0}{\trace_1} = \bot$ or
    $\cdenclause{c_2}{\delta}{\lambda}{\gamma}{t_0}{\trace_2} = \bot$,
    then the result follows from the definition of $\leq$. So assume
    therefore that
    $\cdenclause{c_1}{\delta}{\lambda}{\gamma}{t_0}{\trace_1} =
    \lift{v_1}$ and
    $\cdenclause{c_2}{\delta}{\lambda}{\gamma}{t_0}{\trace_2} =
    \lift{v_2}$. It then follows from the induction hypothesis and the
    definition of $\leq$ that also
    $\cdenclause{c_1}{\delta'}{\lambda}{\gamma}{t_0}{\trace_1} =
    \lift{v_1}$ and 
    $\cdenclause{c_2}{\delta'}{\lambda}{\gamma}{t_0}{\trace_2} =
    \lift{v_2}$, but then by the equations above the result follows.
  \item[$c \equiv \cordefault$:]
    Similar to the case for $c \equiv \canddefault$.
  \item[$c \equiv \cifthenelsedefault$:]
    Follows directly from the induction hypothesis.
  \item[$c \equiv \cinstantiatedefault$:]
    We must now show that
    \[
    \delta(f)(\cdenexp{\vec{e}}{\gamma})(\cdenaexp{\vec{e_a}}{\lambda})
    \sqsubseteq
    \delta'(f)(\cdenexp{\vec{e}}{\gamma})(\cdenaexp{\vec{e_a}}{\lambda}),
    \]
    but this follows from the assumption that $\delta \sqsubseteq \delta'$.
  \end{itemize}
  
  ~

  \emph{Preservation of limits:}
  We must now show that $\cdenclause{c}{(\bigsqcup_i
    \delta_i)}{}{}{}{} = \bigsqcup_i\cdenclause{c}{\delta_i}{}{}{}{}$,
  i.e., that $\cdenclause{c}{(\bigsqcup_i
    \delta_i)}{\lambda}{\gamma}{t_0}{\trace} = (\bigsqcup_i
  \cdenclause{c}{\delta_i)}{\lambda}{\gamma}{t_0}{\trace}$, for all
  $\lambda \in \dendom{\Lambda}$, $\gamma \in \dendom{\Gamma}$, $t_0
  \in \timeset$, and $\trace \in \traceset{A \cup \cod{\lambda}}$. But since
  the partial order on $\dendom{\ctclause{\Delta}{\Lambda}{\Gamma}{c}{A}}$ is
  the point-wise ordering, it follows that $(\bigsqcup_i
  \cdenclause{c}{\delta_i)}{\lambda}{\gamma}{t_0}{\trace} = \bigsqcup_i
  (\cdenclause{c}{\delta_i}{\lambda}{\gamma}{t_0}{\trace})$. (I.e., the
  limit of a chain of functions is defined as the point-wise limits.) So
  it remains to show that
  \[
  \cdenclause{c}{(\bigsqcup_i
    \delta_i)}{\lambda}{\gamma}{t_0}{\trace} = \bigsqcup_i
  (\cdenclause{c}{\delta_i}{\lambda}{\gamma}{t_0}{\trace}),
  \]
  which is shown by structural induction on $c$:
  \begin{itemize}\itemsep=5pt
  \item[$c \equiv \cempty$:]
    Follows directly, since the template environment is not used.
  \item[$c \equiv \catomic{e_a}{k(\vec{x})}{x}{e}{e_d}{c'}$:]
    There are three cases in the definition, but only case (a) is
    interesting, since the template environment is not used in the other
    two cases. So assume that $\trace =
    \event{t}{\cdenaexp{e_a}{\lambda}}{\emptychoice}{k(\vec{d})}\trace'$
    and that $\cdenclause{c}{(\bigsqcup_i
      \delta_i)}{\lambda}{\gamma}{t_0}{\trace} =
    \cdenclause{c'}{(\bigsqcup_i \delta_i)}{\lambda}{\gamma[\vec{x}
      \mapsto \vec{d}, x \mapsto t' - t]}{(t+1)}{\trace'}$. Then since the
    case tests in the definitions do not depend on the template
    environment, we must also have that
    $\cdenclause{c}{\delta_i}{\lambda}{\gamma}{t_0}{\trace} =
    \cdenclause{c'}{\delta_i}{\lambda}{\gamma[\vec{x} \mapsto \vec{d},
      x \mapsto t' - t]}{(t+1)}{\trace'}$, for all $i$. So we 
    must show that
    \begin{align*}
      &\cdenclause{c'}{(\bigsqcup_i \delta_i)}{\lambda}{\gamma[\vec{x}
        \mapsto \vec{d}, x \mapsto t' - t]}{(t+1)}{\trace'}
      =\\
      &\bigsqcup_i
      \cdenclause{c'}{\delta_i}{\lambda}{\gamma[\vec{x}
        \mapsto \vec{d}, x \mapsto t' - t]}{(t+1)}{\trace'}.
    \end{align*}
    But this follows from the induction hypothesis ($c'$ is a proper
    sub clause of $c$).
  \item[$c \equiv \catomicp{\vec{e_a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}$:]
    There are three cases in the definition, but only case (a') and (b')
    are interesting, since the template environment is not used case
    (c').
    \begin{itemize}
    \item[(a')] Identical with case (a) above.
    \item[(b')] Now, $\cdenclause{c}{(\bigsqcup_i
        \delta_i)}{\lambda}{\gamma}{t_0}{\trace} = 
      \cdenclause{c_2}{(\bigsqcup_i
        \delta_i)}{\lambda}{\gamma}{(t_2+1)}{\trace}$, where
      $\cdendexp{e_d}{\gamma}{t_0} = [t_1;t_2]$ and
      $\trace = \emptytrace \lor \tracestart(\trace) > t_2$. But then we
      must also have that
      $\cdenclause{c}{\delta_i}{\lambda}{\gamma}{t_0}{\trace} =
      \cdenclause{c_2}{\delta_i}{\lambda}{\gamma}{(t_2+1)}{\trace}$,
      for all $i$, as the case tests in the definition do not depend
      on the template environment. So we
      must show that
      \[
      \cdenclause{c_2}{(\bigsqcup_i \delta_i)}{\lambda}{\gamma}{(t_2+1)}{\trace}
      = \bigsqcup_i
      \cdenclause{c_2}{\delta_i}{\lambda}{\gamma}{(t_2+1)}{\trace}.
      \]
      But this follows from the induction hypothesis ($c_2$ is a proper
      sub clause of $c$).
    \end{itemize}
  \item[$c \equiv \canddefault$:]
    Follows immediately from the induction hypothesis and the
    compositional definition of $\otimes_\bot$.
  \item[$c \equiv \cordefault$:]
    Follows immediately from the induction hypothesis and the
    compositional definition of $\oplus_\bot$.
  \item[$c \equiv \cifthenelsedefault$:]
    Follows directly from the induction hypothesis.
  \item[$c \equiv \cinstantiatedefault$:]
    We must now show that
    \[
    (\bigsqcup_i \delta_i)(f)(\cdenexp{\vec{e}}{\gamma})(\cdenaexp{\vec{e_a}}{\lambda})
    = \bigsqcup_i
    (\delta_i(f)(\cdenexp{\vec{e}}{\gamma})(\cdenaexp{\vec{e_a}}{\lambda})),
    \]
    but this follows from definition of the point-wise ordering on
    $\dendom{\Delta}$.
  \end{itemize}
  \qed
\end{proof}

\refthm{lemma:inclusive}
\begin{proof}
  Assume that $P(\delta_i)$ holds for all $i$, and assume that
  \begin{align}
    (\bigsqcup_i \delta_i)(f)(\vec{d})(\vec{a})(t_0)(\trace) =
    \lift{(t,B)}. \label{lemma:inclusive1}
  \end{align}
  We must then show that
  \begin{align}
    & \trace = \emptytrace \Rightarrow t \geq
    t_0 \label{lemma:inclusive2}\\
    & \tracestart(\trace) = t' \Rightarrow t \geq
    \min(t_0,t') \label{lemma:inclusive3}\\
    & \forall \trace' \in \traceset{A}. \left( \trace_{t} =
      \trace'_{t} \land (\bigsqcup_i \delta_i)(f)
      (\vec{d})(\vec{a})(t_0)(\trace') \neq \bot \right)
    \Rightarrow \label{lemma:inclusive4}\\
    & \qquad
    (\bigsqcup_i \delta_i)(f)(\vec{d})(\vec{a})(t_0)(\trace') =
    \lift{(t,B)}.\notag
  \end{align}
  Because of the point-wise ordering, it follows from
  (\ref{lemma:inclusive1}) that
  \[
    \bigsqcup_i \delta_i(f)(\vec{d})(\vec{a})(t_0)(\trace) = \lift{(t,B)}.
  \]
  But this can only happen if $\delta_{i}(f)(\vec{d})(\vec{a})(t_0)(\trace) =
  \lift{(t,B)}$, from some index $j$ (due to the ordering on
  $\verdictsetlift{\vec{a}}$), and then from the assumption,
  (\ref{lemma:inclusive2}) and (\ref{lemma:inclusive3}) follow
  directly. In order to show (\ref{lemma:inclusive4}), we again get from
  the point-wise ordering that it suffices to show
  \begin{align}
    \forall \trace' \in \traceset{A}. \left( \trace_{t} = \trace'_{t}
      \land \bigsqcup_i \delta_i(f)(\vec{d})(\vec{a})(t_0)(\trace')
      \neq \bot \right) \Rightarrow  \label{lemma:inclusive5}\\
    \bigsqcup_i
    \delta_i(f)(\vec{d})(\vec{a})(t_0)(\trace') = \lift{(t,B)}. \qquad\notag
  \end{align}
  So assume that $\trace'_t = \trace_t$ and that $\bigsqcup_i
  \delta_i(f)(\vec{d})(\vec{a})(t_0)(\trace') \neq \bot$. It then
  follows from the ordering on $\verdictsetlift{A}$ that
  $\delta_i(f)(\vec{d})(\vec{a})(t_0)(\trace') \neq \bot$ from some
  index $j'$, and consequently it follows from the assumption that
  $\delta_i(f)(\vec{d})(\vec{a})(t_0)(\trace') = \lift{(t,B)}$ from index
  $\max(j,j')$. But then $\bigsqcup_i
  \delta_i(f)(\vec{d})(\vec{a})(t_0)(\trace') = \lift{(t,B)}$ as required.
  \qed
\end{proof}

\refthm{lemma:cpreservesp}
\begin{proof}
  Assume that $\cdenclause{c}{\delta}{\lambda}{\gamma}{t_0}{\trace} =
  \lift{(t,B)}$, $\trace'_t = \trace_t$, and
  $\cdenclause{c}{\delta}{\lambda}{\gamma}{t_0}{\trace'} \neq \bot$.
  We then show by structural induction on $c$ that
  \begin{align}
    & \trace = \emptytrace \Rightarrow t \geq
    t_0 \label{lemma:cpreservesp1}\\
    & \tracestart(\trace) = t' \Rightarrow t \geq
    \min(t_0,t') \label{lemma:cpreservesp2}\\
    & \cdenclause{c}{\delta}{\lambda}{\gamma}{t_0}{\trace'} =
    \lift{(t,B)}. \label{lemma:cpreservesp3}
  \end{align}
  \begin{itemize}\itemsep=5pt
  \item[$c \equiv \cempty$:]
    Now it must be the case that $\trace =
    \event{t}{a}{\choice}{k(\vec{d})}\trace''$ for some $\trace''$, and
    $B = \{a\}$. Clearly then (\ref{lemma:cpreservesp1}) and
    (\ref{lemma:cpreservesp2}) follow. Now since $\trace_t =
    \trace'_t$ we must have that $\trace' =
    \event{t}{a}{\choice}{k(\vec{d})}\trace'''$ for some $\trace'''$, 
    and consequently (\ref{lemma:cpreservesp3}) follows.
  \item[$c \equiv \catomic{e_a}{k(\vec{x})}{x}{e}{e_d}{c'}$:]
    There are three sub cases:
    \begin{itemize}
    \item[(a)] Now $\cdenclause{c}{\delta}{\lambda}{\gamma}{t_0}{\trace} 
      = \cdenclause{c'}{\delta}{\lambda}{\gamma[\vec{x}
      \mapsto \vec{d}, x \mapsto t' - t]}{(t'+1)}{\trace''} = \lift{(t,B)}$,
      where $\trace =
      \event{t'}{\cdenaexp{e_a}{\lambda}}{\emptychoice}{k(\vec{d})}\trace''$. (\ref{lemma:cpreservesp1})
      then follows trivially, and (\ref{lemma:cpreservesp2})
      follows from the induction hypothesis, i.e., $t \geq
      t' + 1$ (relies on the fact that time stamps are increasing in
      event traces). Now since $\trace_t = \trace'_t$ we must have
      that $\trace' =
      \event{t'}{\cdenaexp{e_a}{\lambda}}{\emptychoice}{k(\vec{d})}\trace'''$
      where $\trace''_t = \trace'''_t$. (\ref{lemma:cpreservesp3})
      then follows from the induction hypothesis.
    \item[(b)] Now $\cdenclause{c}{\delta}{\lambda}{\gamma}{t_0}{\trace}
      = \lift{(t_2,\{a\})}$, where $\cdendexp{e_d}{\gamma}{t_0} =
      [t_1;t_2]$, $\cdenaexp{e_a}{\lambda} = a$, and $\trace = 
      \emptytrace \lor \tracestart(\trace) > t_2$. Then since $t_2 \geq
      t_0$, cf. the definition of $\cdendexp{\cdot}{}{}$,
      (\ref{lemma:cpreservesp1}) and (\ref{lemma:cpreservesp2})
      follow. Now since $\trace_t = \trace'_t$ we must also have that
      $\trace' = \emptytrace \lor \tracestart(\trace') > t_2$, so
      (\ref{lemma:cpreservesp3}) follows.
    \item[(c)] Now $\trace =
      \event{t}{a}{\choice}{k(\vec{d})}\trace''$, for some $\trace''$,
      and $B = \{a\}$.  (\ref{lemma:cpreservesp1}) and
      (\ref{lemma:cpreservesp2}) then follow directly. Then since
      $\trace_t = \trace'_t$, we must have that $\trace' =
      \event{t}{a}{\choice}{k(\vec{d})}\trace'''$, for some $\trace'''$,
      so also (\ref{lemma:cpreservesp3}) follows.
    \end{itemize}
  \item[$c \equiv \catomicp{\vec{e_a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}$:]
    There are three sub cases:
    \begin{itemize}
    \item[(a')] Identical with case (a) above.
    \item[(b')] Now $\cdenclause{c}{\delta}{\lambda}{\gamma}{t_0}{\trace}
      = \cdenclause{c_2}{\delta}{\lambda}{\gamma}{(t_2+1)}{\trace}$, where
      $\cdendexp{e_d}{\gamma}{t_0} = [t_1;t_2]$, and $\trace = 
      \emptytrace \lor \tracestart(\trace) >
      t_2$. But then the result follows directly from the induction
      hypothesis and the fact that $t_2 \geq t_0$, cf. the definition
      of $\cdendexp{\cdot}{}{}$.
    \item[(c')] Identical with case (c) above.
    \end{itemize}
  \item[$c \equiv \canddefault$:]
    Now by the definition of $\otimes_\bot$ it follows that
    $\cdenclause{c_1}{\delta}{\lambda}{\gamma}{t_0}{\trace_1} =
    \lift{v_1}$ and
    $\cdenclause{c_2}{\delta}{\lambda}{\gamma}{t_0}{\trace_2} = 
    \lift{v_2}$, where $v_1 \otimes v_2 = (t,B)$ and
    $\tracesplit(\trace) = (\trace_1,\trace_2)$. We therefore have
    three possible sub cases:
    \begin{itemize}
    \item $v_1 = (t,B)$ and $v_2 = \conforming \lor (v_2 = (t_2,B_2)
      \land t < t_2)$:
      (\ref{lemma:cpreservesp1}) and
      (\ref{lemma:cpreservesp2}) follow directly from the
      induction hypothesis applied to $c_1$. Now, since $\trace'_t
      = \trace_t$ it follows from the induction hypothesis
      applied to $c_1$ (and the definition of $\tracesplit$) that
      $\cdenclause{c_1}{\delta}{\lambda}{\gamma}{t_0}{\trace'_1} =
      \lift{(t,B)}$, and by assumption we must have that
      $\cdenclause{c_2}{\delta}{\lambda}{\gamma}{t_0}{\trace'_2} =
      \lift{v_2'}$. So it suffices to show that $v_2' = (t_2',B_2')
      \Rightarrow t < t_2'$. Assume for the sake
      of contradiction that $v_2' = (t_2',B_2') \land t \geq
      t_2'$. It then follows from the induction hypothesis applied to
      $c_2$ that $v_2 = v_2'$, contradicting the assumption.
    \item $v_2 = (t,B)$ and $v_1 = \conforming \lor (v_1 = (t_1,B_1)
      \land t < t_1)$: Similar to the case above.
    \item $v_1 = (t,B_1)$, $v_2 = (t,B_2)$, and $B = B_1 \cup B_2$:
      (\ref{lemma:cpreservesp1}) and 
      (\ref{lemma:cpreservesp2}) follow directly from the
      induction hypothesis applied to either $c_1$ or $c_2$. It also
      follows from the induction hypothesis (and the definition of
      $\tracesplit$) that
      $\cdenclause{c_1}{\delta}{\lambda}{\gamma}{t_0}{\trace'_1} =
      \lift{(t,B_1)}$
      and $\cdenclause{c_2}{\delta}{\lambda}{\gamma}{t_0}{\trace'_2} =
      \lift{(t,B_2)}$, and consequently (\ref{lemma:cpreservesp3})
      follows from the definition of $\otimes_\bot$.
    \end{itemize}
  \item[$c \equiv \cordefault$:]
    Now by the definition of $\oplus_\bot$ we get that
    $\cdenclause{c_1}{\delta}{\lambda}{\gamma}{t_0}{\trace} =
    \lift{(t_1,B_1)}$ and
    $\cdenclause{c_2}{\delta}{\lambda}{\gamma}{t_0}{\trace} = 
    \lift{(t_2,B_2)}$, where $(t_1,B_1) \oplus (t_2,B_2) = (t,B)$. It
    therefore follows from the definition of $\oplus$ that $t =
    \max(t_1,t_2) \geq t_1,t_2$, and 
    consequently (\ref{lemma:cpreservesp1}) and
    (\ref{lemma:cpreservesp2}) follow directly from the induction
    hypothesis applied to $c_1$ and $c_2$. Finally it also follows
    from the induction hypothesis that 
    $\cdenclause{c_1}{\delta}{\lambda}{\gamma}{t_0}{\trace'} = 
    \lift{(t_1,B_1)}$ and
    $\cdenclause{c_2}{\delta}{\lambda}{\gamma}{t_0}{\trace'} =
    \lift{(t_2,B_2)}$, and consequently the result follows.
  \item[$c \equiv \cifthenelsedefault$:]
    Follows by induction on the sub clauses.
  \item[$c \equiv \cinstantiatedefault$:]
    Follows from the assumption that $P(\delta)$ holds.
  \end{itemize}
  \qed
\end{proof}

\refthm{theorem:guardedness}
\begin{proof}
  The proof is by induction on the length of $\trace$:
  \begin{itemize}\itemsep=5pt
  \item[$\trace = \emptytrace$:] We first use Lemma
    \ref{lemma:guardednessbyconstruction} to construct a derivation,
    $\cguarded{D}{\emptyset}{c}$. The result is then shown by (inner)
    induction on this derivation:
    \begin{itemize}[]\itemsep=5pt
    \item \fbox{\scriptsize \AxiomC{$\cguarded{D}{\emptyset}{\cempty}$}
        \DisplayProof{}}

      It follows directly that
      $\cdenclause{c}{\cdencontext{D}}{\lambda}{\gamma}{t}{\trace}
      \neq \bot$ (regardless of what $\trace$ is).
    \item \fbox{\scriptsize \AxiomC{$\cguarded{D}{\emptyset}{\catomic{e_a}{k(\vec{x})}{x}{e}{e_d}{c'}}$}
        \DisplayProof{}}

      Now since $\trace = \emptytrace$, it follows directly that
      $\cdenclause{c}{\cdencontext{D}}{\lambda}{\gamma}{t}{\trace}
      \neq \bot$ (only case (b) can occur).
    \item \fbox{\scriptsize
        \AxiomC{$\cguarded{D}{\emptyset}{c_2}$}
        \UnaryInfC{$\cguarded{D}{\emptyset}{\catomicp{\vec{e_a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}$}
        \DisplayProof{}}

      Now in the definition of $\cdenclause{c}{}{}{}{}{}$ there are
      three cases, but only cases (a') and (b') are interesting, as the
      result follows directly in case (c'). Furthermore, case (a')
      cannot occur as $\trace = \emptytrace$, so it remains to show
      that $\cdenclause{c_2}{\cdencontext{D}}{\lambda}{\gamma}{(t_2+1)}{\trace}
      \neq \bot$. But this follows from the inner induction hypothesis.
    \item \fbox{\scriptsize \AxiomC{$\cguarded{D}{\emptyset}{c_1}$}
        \AxiomC{$\cguarded{D}{\emptyset}{c_2}$}
        \BinaryInfC{$\cguarded{D}{\emptyset}{\canddefault}$}
        \DisplayProof{}}

      Now $\cdenclause{c}{\cdencontext{D}}{\lambda}{\gamma}{t}{\trace}
      =
      \cdenclause{c_1}{\cdencontext{D}}{\lambda}{\gamma}{t}{\trace_1}
      \otimes_\bot
      \cdenclause{c_2}{\cdencontext{D}}{\lambda}{\gamma}{t}{\trace_2}$,
      so it follows from the inner induction hypothesis that
      $\cdenclause{c_1}{\cdencontext{D}}{\lambda}{\gamma}{t}{\trace_1}
      \neq \bot$ and
      $\cdenclause{c_2}{\cdencontext{D}}{\lambda}{\gamma}{t}{\trace_2}
      \neq \bot$. Hence by the semantics of $\otimes_\bot$ the result
      follows.
    \item \fbox{\scriptsize \AxiomC{$\cguarded{D}{\emptyset}{c_1}$}
        \AxiomC{$\cguarded{D}{\emptyset}{c_2}$}
        \BinaryInfC{$\cguarded{D}{\emptyset}{\cordefault}$}
        \DisplayProof{}}
      
      Similar to the case $c \equiv \canddefault$.
    \item \fbox{\scriptsize \AxiomC{$\cguarded{D}{\emptyset}{c_1}$}
        \AxiomC{$\cguarded{D}{\emptyset}{c_2}$}
        \BinaryInfC{$\cguarded{D}{\emptyset}{\cifthenelsedefault}$}
        \DisplayProof{}}

      Similar to the case $c \equiv \canddefault$.
    \item \fbox{\scriptsize \AxiomC{$f \not\in \emptyset$}
        \AxiomC{$\cinstantiate{f}{\vec{x}}{\vec{y}} = c \in D$}
        \AxiomC{$\cguarded{D}{\{f\}}{c}$}
        \TrinaryInfC{$\cguarded{D}{\emptyset}{\cinstantiate{f}{\vec{e}}{\vec{e_a}}}$}
        \DisplayProof{}}

      Now $\cdencontext{D}$ is the least fixed-point of the function
      $\Phi$ from Figure \ref{fig:cdenclausecontract}, which means that
      $\cdencontext{D}(f)(\vec{d})(\vec{a}) =
      \cdenclause{c}{\cdencontext{D}}{[\vec{y} \mapsto
        \vec{a}]}{[\vec{x} \mapsto \vec{d},\vec{y} \mapsto
        \vec{a}]}{}$. Hence
      \[
      \cdenclause{\cinstantiate{f}{\vec{e}}{\vec{e_a}}}{\cdencontext{D}}{\lambda}{\gamma}{t}{\trace}
      = 
      \cdenclause{c}{\cdencontext{D}}{[\vec{y} \mapsto
        \vec{a}]}{[\vec{x} \mapsto \vec{d},\vec{y} \mapsto
        \vec{a}]}{t}{\trace},
      \]
      where $\cdenexp{\vec{e}} = \vec{d}$ and $\cdenaexp{\vec{e_a}} =
      \vec{a}$. The result then follows from the inner induction
      hypothesis.
    \end{itemize}
  \item[$\trace = e\trace'$:] We again use Lemma
    \ref{lemma:guardednessbyconstruction} to construct a derivation, 
    $\cguarded{D}{\emptyset}{c}$, and prove the result by (inner)
    induction on this derivation (we only include the cases where the
    proofs are different from the cases with $\trace = \emptytrace$):
    \begin{itemize}[]\itemsep=5pt
    \item \fbox{\scriptsize \AxiomC{$\cguarded{D}{\emptyset}{\catomic{e_a}{k(\vec{x})}{x}{e}{e_d}{c'}}$}
        \DisplayProof{}}

      Now in the definition of $\cdenclause{c}{}{}{}{}{}$ there are
      three cases, but only case (a) is interesting, as the result follows
      directly in the other two cases. So assume that
      $\cdenclause{c}{\cdencontext{D}}{\lambda}{\gamma}{t}{\trace} =
      \cdenclause{c'}{\cdencontext{D}}{\lambda}{\gamma[\vec{x} \mapsto
        \vec{d}, x \mapsto t' - t]}{(t'+1)}{\trace'}$. Then since
      $\ctclause{\Delta}{\Lambda}{\Gamma}{c}{A}$, there is also a
      derivation $\ctclause{\Delta}{\Lambda}{\Gamma}{c'}{A'}$, for
      some $A'$, and consequently the result follows from the
      \emph{outer} induction hypothesis.
    \item \fbox{\scriptsize
        \AxiomC{$\cguarded{D}{\emptyset}{c_2}$}
        \UnaryInfC{$\cguarded{D}{\emptyset}{\catomicp{\vec{e_a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}$}
        \DisplayProof{}}

      Now in the definition of $\cdenclause{c}{}{}{}{}{}$ there are
      three cases, but only cases (a') and (b') are interesting, as the
      result follows directly in case (c').
      \begin{itemize}
      \item[(a'):] Similar to case (a) above (utilizing the outer
        induction hypothesis).
      \item[(b'):] Now
        $\cdenclause{c}{\cdencontext{D}}{\lambda}{\gamma}{t}{\trace}
        =
        \cdenclause{c_2}{\cdencontext{D}}{\lambda}{\gamma}{(t_2+1)}{\trace}$,
        so it remains to show
        that $\cdenclause{c_2}{\cdencontext{D}}{\lambda}{\gamma}{(t_2+1)}{\trace}
        \neq \bot$. But this follows from the inner induction hypothesis.
      \end{itemize}
    \end{itemize}
  \end{itemize}
  \qed
\end{proof}

\refthm{lemma:substclause}
\begin{proof}
  The proof is by induction on the typing derivation. We only include
  some of the cases, since the other cases are similar:
  \begin{itemize}[]\itemsep=5pt
  \item \hspace{-4.7pt}\fbox{\scriptsize \AxiomC{$\begin{array}{c}\\
          \tp(k) = (\type_1,\ldots,\type_n)\\
          \Gamma' = (\Gamma \cup [x \mapsto \type])[x_1 \mapsto \type_1, \ldots, x_n
          \mapsto \type_n]\\
          \Gamma'' = \Gamma'[y \mapsto \ctpduration]
        \end{array}$}
      \AxiomC{$\begin{array}{c}
          \ctaexp{\Lambda}{e_a}{A}\\
          \ctexp{\Gamma'}{e'}{\ctpbool}\\
          \ctdexp{\Gamma \cup [x \mapsto \type]}{e_d}\\
          \ctclause{\Delta}{\Lambda'}{\Gamma''}{c}{A'}
        \end{array}$}
      \BinaryInfC{$\ctclause
        {\Delta}{\Lambda \cup \Lambda'}{\Gamma \cup [x \mapsto \type]}{\catomic{e_a}{k(x_1,\ldots,x_n)}{y}{e'}{e_d}{c}}{A
          \cup A'}$}
      \DisplayProof{}}
    
    Now
    \begin{align*}
      &(\catomic{e_a}{k(x_1,\ldots,x_n)}{y}{e'}{e_d}{c})[e/x] =\\
      &\catomic{e_a}{k(x_1,\ldots,x_n)}{y}{e''}{e_d[e/x]}{c'},
    \end{align*}
    where
    \[
    e'' = \left\{ \begin{array}{ll} 
        e'[e/x], & \mbox{if } x \not\in \{x_1,\ldots,x_n\}\\
        e', & \mbox{otherwise}
      \end{array} \right. \mbox{ and}\quad
    c' = \left\{ \begin{array}{ll}
        c[e/x], & \mbox{if } x \not\in \{x_1,\ldots,x_n,y\}\\
        c, & \mbox{otherwise}
      \end{array} \right. .
    \]
    So in order to show the typing derivation, it suffices to show that
    \begin{align}
      \ctexp{\Gamma'_s}{e''&}{\ctpbool} \label{lemma:substclause1}\\
      \ctdexp{\Gamma}{e_d[e/x]&} \label{lemma:substclause2}\\
      \ctclause{\Delta}{\Lambda'}{\Gamma''_s}{c'&}{A'} \label{lemma:substclause3}
    \end{align}
    where $\Gamma'_s = \Gamma[x_1 \mapsto \type_1, \ldots, x_n \mapsto
    \type_n]$ and $\Gamma''_s = \Gamma'_s[y \mapsto \ctpduration]$.
    \begin{itemize}
    \item[(\ref{lemma:substclause1}):]
      In case that $x \not\in \{x_1,\ldots,x_n\}$, we have that $e'' =
      e'[e/x]$, and consequently the result follows from Lemma
      \ref{lemma:substexp}. In case that $x \in \{x_1,\ldots,x_n\}$,
      we have that $e'' = e'$. But then $\Gamma'_s = \Gamma'$ from
      which the result follows.
    \item[(\ref{lemma:substclause2}):]
      Follows from Lemma \ref{lemma:substexp}.
    \item[(\ref{lemma:substclause3}):]
      In case that $x \not\in \{x_1,\ldots,x_n,y\}$, we have that $c'
      = c[e/x]$, and the result then follows from the induction
      hypothesis since $\Gamma_s'' \cup [x \mapsto \type] = \Gamma''$. In case that $x \in \{x_1,\ldots,x_n,y\}$, we have
      that $c' = c$. But then $\Gamma''_s = \Gamma''$ from
      which the result follows.
    \end{itemize}

    We must then show the equality
    \begin{align*}
      &\cdenclause{\catomic{e_a}{k(\vec{x})}{y}{e''}{e_d[e/x]}{c'}}{\delta}{\lambda}{\gamma} 
      =\\
      &\cdenclause{\catomic{e_a}{k(\vec{x})}{y}{e'}{e_d}{c}}{\delta}{\lambda}{\gamma[x
        \mapsto \cdenexp{e}{\gamma}]}.
    \end{align*}
    By the definition of $\cdenclause{\cdot}{}{}{}{}{}$ it suffices to show that
    \begin{align}
      \cdenexp{e''}{\gamma[\vec{x} \mapsto \vec{d}]} &=
      \cdenexp{e'}{(\gamma[x \mapsto \cdenexp{e}{\gamma}])[\vec{x}
        \mapsto \vec{d}]}\label{lemma:substclause4}\\
      \cdendexp{e_d[e/x]}{\gamma} &=
      \cdendexp{e_d}{\gamma[x \mapsto
        \cdenexp{e}{\gamma}]}\label{lemma:substclause5}\\
      \cdenclause{c'}{\delta}{\lambda}{\gamma[\vec{x} \mapsto \vec{d},
        y \mapsto n]}{}{} &= \cdenclause{c}{\delta}{\lambda}{(\gamma[x \mapsto
        \cdenexp{e}{\gamma}])[\vec{x} \mapsto \vec{d},
        y \mapsto n]}{}{},\label{lemma:substclause6}
    \end{align}
    for all $\vec{d}$ and $n$.
    \begin{itemize}
    \item[(\ref{lemma:substclause4}):]
      In case that $x \not\in \vec{x}$, we have that $e'' = e'[e/x]$,
      and the result then follows from Lemma \ref{lemma:substexp}. In
      case that $x \in \vec{x}$, we have that $e'' = e'$. But then
      $\gamma[\vec{x} \mapsto \vec{d}] = (\gamma[x \mapsto
      \cdenexp{e}{\gamma}])[\vec{x} \mapsto \vec{d}]$, from which the
      result follows.
    \item[(\ref{lemma:substclause5}):]
      Follows from Lemma \ref{lemma:substexp}.
    \item[(\ref{lemma:substclause6}):]
      In case that $x \not\in \vec{x} \land x \neq y$, we have that
      $c' = c[e/x]$, and the result then follows from the induction
      hypothesis. In case that $x \in \vec{x} \lor x = y$, we have
      that $c' = c$. But then $\gamma[\vec{x} \mapsto \vec{d}, y
      \mapsto n] = (\gamma[x \mapsto \cdenexp{e}{\gamma}])[\vec{x}
      \mapsto \vec{d}, y \mapsto n]$, from which the result follows.
    \end{itemize}
  \item \fbox{\scriptsize
      \AxiomC{$\ctclause{\Delta}{\Lambda_1}{\Gamma \cup [x \mapsto
          \type]}{c_1}{A_1}$}
      \AxiomC{$\ctclause{\Delta}{\Lambda_2}{\Gamma \cup [x \mapsto
          \type]}{c_2}{A_2}$}
      \BinaryInfC{$\ctclause{\Delta}{\Lambda_1 \cup
          \Lambda_2}{\Gamma \cup [x \mapsto
          \type]}{\canddefault}{A_1 \cup A_2}$}
      \DisplayProof{}}
    
    Now, $(\canddefault)[e/x] = \cand{c_1[e/x]}{c_2[e/x]}$, so in order
    to show the typing derivation, it suffices to show that
    $\ctclause{\Delta}{\Lambda_1}{\Gamma}{c_1[e/x]}{A_1}$ and
    $\ctclause{\Delta}{\Lambda_2}{\Gamma}{c_2[e/x]}{A_2}$. But this
    follows from the induction hypothesis. Similarly, the equality
    \[
    \cdenclause{\cand{c_1[e/x]}{c_2[e/x]}}{\delta}{\lambda}{\gamma} =
    \cdenclause{\canddefault}{\delta}{\lambda}{\gamma[x \mapsto
      \cdenexp{e}{\gamma}]},
    \]
    follows directly from the induction hypothesis and the
    compositionality of $\otimes$.
  \item \fbox{\scriptsize \AxiomC{$\Delta(f) = ((\type_1,\ldots,\type_m),n)$}
      \AxiomC{$\ctaexp{\Lambda}{(e_{a_1},\ldots,e_{a_n})}{A}$}
      \AxiomC{$\forall i \in \{1,\ldots,m\}. \ctexp{\Gamma}{e_i}{\type_i}$}
      \TrinaryInfC{$\ctclause{\Delta}{\Lambda}{\Gamma}{\cinstantiate{f}{e_1,\ldots,e_m}{e_{a_1},\ldots,e_{a_n}}}{A}$}
      \DisplayProof{}}
   
    Now, $\cinstantiate{f}{e_1,\ldots,e_m}{e_{a_1}, \ldots
      e_{a_n}}[e/x] =
    \cinstantiate{f}{e_1[e/x],\ldots,e_m[e/x]}{e_{a_1}, \ldots
      e_{a_n}}$, so in order to show the typing derivation, it
    suffices to show that $\ctexp{\Gamma}{e_i[e/x]}{\type_i}$, for
    $i=1,\ldots,m$. But this follows from Lemma
    \ref{lemma:substexp}. In order to show the equality
    \begin{align*}
    &\cdenclause{\cinstantiate{f}{e_1[e/x],\ldots,e_m[e/x]}{e_{a_1}, \ldots
        e_{a_n}}}{\delta}{\lambda}{\gamma} =\\
    &\cdenclause{\cinstantiate{f}{e_1,\ldots,e_m}{e_{a_1}, \ldots
        e_{a_n}}}{\delta}{\lambda}{\gamma[x \mapsto
      \cdenexp{e}{\gamma}]},
    \end{align*}
    we must show that
    \begin{align*}
      &\delta(f)(\cdenexp{e_1[e/x]}{\gamma},\ldots,\cdenexp{e_m[e/x]}{\gamma})(\cdenaexp{e_{a_1}}{\lambda},
      \ldots \cdenaexp{e_{a_n}}{\lambda}) =\\
      &\delta(f)(\cdenexp{e_1}{\gamma[x \mapsto \cdenexp{e}{\gamma}]},
      \ldots, \cdenexp{e_m}{\gamma[x \mapsto
      \cdenexp{e}{\gamma}]})(\cdenaexp{e_{a_1}}{\lambda},
      \ldots \cdenaexp{e_{a_n}}{\lambda}).
    \end{align*}
    But this again follows from Lemma \ref{lemma:substexp}.
  \end{itemize}
  \qed
\end{proof}

\refthm{lemma:substagent}
\begin{proof}
  The proof is by induction on the typing derivation. We only include
  some of the cases:
  \begin{itemize}[]\itemsep=5pt
  \item \fbox{\scriptsize \AxiomC{$\begin{array}{c}\\
          \tp(k) = (\type_1,\ldots,\type_n)\\
          \Gamma' = \Gamma[x_1 \mapsto \type_1, \ldots, x_n
          \mapsto \type_n]\\
          \Gamma'' = \Gamma'[y \mapsto \ctpduration]
        \end{array}$}
      \AxiomC{$\begin{array}{c}
          \ctaexp{\Lambda}{e_a}{A}\\
          \ctexp{\Gamma'}{e}{\ctpbool}\\
          \ctdexp{\Gamma}{e_d}\\
          \ctclause{\Delta}{\Lambda'}{\Gamma''}{c}{A'}
        \end{array}$}
      \BinaryInfC{$\ctclause
        {\Delta}{\Lambda \cup \Lambda'}{\Gamma}{\catomic{e_a}{k(x_1,\ldots,x_n)}{y}{e}{e_d}{c}}{A
          \cup A'}$}
      \DisplayProof{}}
    
    Now
    \begin{align*}
      &(\catomic{e_a}{k(x_1,\ldots,x_n)}{y}{e}{e_d}{c})\langle a/x
      \rangle =\\
      &\catomic{e_a \langle a/x
        \rangle}{k(x_1,\ldots,x_n)}{y}{e}{e_d}{c\langle a/x \rangle},
    \end{align*}
    so in order to show the typing derivation, it suffices to show
    that
    \begin{align}
      \ctaexp{\Lambda_s}{e_a \langle a/x
        \rangle&}{A_s} \label{lemma:substagent1}\\
      \ctclause{\Delta}{\Lambda_s'}{\Gamma''}{c \langle a/x
        \rangle&}{A_s'} \label{lemma:substagent2}
    \end{align}
    where $\Lambda_s \cup \Lambda_s' = (\Lambda \cup \Lambda')
    \setminus \{x\}$ and $A_s \cup A_s' = A
    \cup A' \cup \{a\}$. We proceed by sub cases on the derivation of 
    $\ctaexp{\Lambda}{e_a}{A}$:
    \begin{itemize}[]
    \item \fbox{\AxiomC{}
        \UnaryInfC{$\ctaexp{\emptyset}{a'}{\{a'\}}$}
        \DisplayProof{}}

      Now, $\Lambda = \emptyset$, so $x \in \Lambda'$,
      and hence from the induction hypothesis it follows that
      $\ctclause{\Delta}{\Lambda' \setminus \{x\}}{\Gamma''}{c
        \langle a/x \rangle}{A' \cup \{a\}}$. But then
      (\ref{lemma:substagent1}) and (\ref{lemma:substagent2}) follow
      with $\Lambda_s = \Lambda = \emptyset$, $\Lambda_s' = \Lambda'
      \setminus \{x\}$, $A_s = A = \{a'\}$, and $A_s' = A' \cup \{a\}$.
    \item \fbox{\AxiomC{}
        \UnaryInfC{$\ctaexp{\{x'\}}{x'}{\emptyset}$}
        \DisplayProof{}}
      
      We now have yet two sub cases:
      \begin{itemize}
      \item[$x = x'$:] In this case, we have that $\Lambda = \{x\}$,
        and (\ref{lemma:substagent1}) follows with $\Lambda_s =
        \emptyset$ and $A_s = \{a\}$. So in order to show
        (\ref{lemma:substagent2}), it suffices to show that
        $\ctclause{\Delta}{\Lambda' \setminus \{x\}}{\Gamma''}{c \langle a/x
          \rangle}{A_s'}$, where $A_s' \cup \{a\} = A' \cup
        \{a\}$. In case $x \in \Lambda'$, the result follows from the
        induction hypothesis (with $A_s' = A' \cup \{a\}$), and in
        case $x \not\in \Lambda$, the result follows directly, as $c
        \langle a/x \rangle = c$ (with $A_s' = A'$). 
      \item[$x \neq x'$:] In this case, we have that $x \in \Lambda'$,
        so it follows from the induction hypothesis that
        $\ctclause{\Delta}{\Lambda' \setminus \{x\}}{\Gamma''}{c
          \langle a/x \rangle}{A' \cup \{a\}}$. Consequently
        (\ref{lemma:substagent1}) follows with $\Lambda_s = \Lambda =
        \{x'\}$ and $A_s = A = \emptyset$, and (\ref{lemma:substagent2})
        follows with $\Lambda_s' = \Lambda' \setminus \{x\}$ and $A_s'
        = A' \cup \{a\}$.
      \end{itemize}
    \end{itemize}

    We must then show the equality
    \begin{align*}
      &\cdenclause{\catomic{e_a \langle a/x
          \rangle}{k(x_1,\ldots,x_n)}{y}{e}{e_d}{c \langle a/x
          \rangle}}{\delta}{\lambda}{}{}{}
      =\\
      &\cdenclause{\catomic{e_a}{k(x_1,\ldots,x_n)}{y}{e}{e_d}{c}}{\delta}{\lambda[x
        \mapsto a]}{}{}{}.
    \end{align*}
    By the definition of $\cdenclause{\cdot}{}{}{}{}{}$ it suffices to show that
    \begin{align}
      \cdenaexp{e_a\langle a/x \rangle}{\lambda} &=
      \cdenexp{e_a}{\lambda[x \mapsto a]}\label{lemma:substagent3}\\
      \cdenclause{c \langle a/x \rangle}{\delta}{\lambda}{}{}{}
      &= \cdenclause{c}{\delta}{\lambda[x \mapsto
        a]}{}{}{},\label{lemma:substagent4}
    \end{align}
    (\ref{lemma:substagent3}) follows immediately from the definition
    of $\cdenaexp{\cdot}{}$, and (\ref{lemma:substagent4}) follows
    from the induction hypothesis.

  \item \fbox{\scriptsize
      \AxiomC{$\ctclause{\Delta}{\Lambda_1}{\Gamma}{c_1}{A_1}$}
      \AxiomC{$\ctclause{\Delta}{\Lambda_2}{\Gamma}{c_2}{A_2}$}
      \BinaryInfC{$\ctclause{\Delta}{\Lambda_1 \cup
          \Lambda_2}{\Gamma}{\canddefault}{A_1 \cup A_2}$}
      \DisplayProof{}}

    Now, if $x \in \Lambda_1$, then it follows from the induction
    hypothesis that $\ctclause{\Delta}{\Lambda_1 \setminus
      \{x\}}{\Gamma}{c_1 \langle a/x \rangle}{A_1 \cup \{a\}}$. If $x
    \not\in \Lambda_1$, then $c_1 \langle a/x \rangle = c_1$ (formally a
    proof by induction), and consequently $\ctclause{\Delta}{\Lambda_1
      \setminus \{x\}}{\Gamma}{c_1 \langle a/x \rangle}{A_1}$. By a
    similar argument, there are two cases for $c_2$, which combined
    yields four cases:

    \begin{itemize}
    \item $\ctclause{\Delta}{\Lambda_1 \setminus
        \{x\}}{\Gamma}{c_1 \langle a/x \rangle}{A_1 \cup \{a\}}$ and
      $\ctclause{\Delta}{\Lambda_2 \setminus 
        \{x\}}{\Gamma}{c_2 \langle a/x \rangle}{A_2 \cup \{a\}}$. In
      this case, $\ctclause{\Delta}{(\Lambda_1 \cup \Lambda_2)
        \setminus \{x\}}{\Gamma}{\cand{c_1 \langle
          a/x \rangle}{c_2 \langle
          a/x \rangle} \rangle}{A_1 \cup A_2 \cup \{a\} \cup \{a\}}$
      as required.
    \item $\ctclause{\Delta}{\Lambda_1 \setminus
        \{x\}}{\Gamma}{c_1 \langle a/x \rangle}{A_1 \cup \{a\}}$ and
      $\ctclause{\Delta}{\Lambda_2 \setminus 
        \{x\}}{\Gamma}{c_2 \langle a/x \rangle}{A_2}$. In
      this case, $\ctclause{\Delta}{(\Lambda_1 \cup \Lambda_2)
        \setminus \{x\}}{\Gamma}{\cand{c_1 \langle
          a/x \rangle}{c_2 \langle
          a/x \rangle} \rangle}{A_1 \cup A_2 \cup \{a\}}$ as required.
    \item $\ctclause{\Delta}{\Lambda_1 \setminus
        \{x\}}{\Gamma}{c_1 \langle a/x \rangle}{A_1}$ and
      $\ctclause{\Delta}{\Lambda_2 \setminus 
        \{x\}}{\Gamma}{c_2 \langle a/x \rangle}{A_2 \cup
        \{a\}}$. Symmetric to the case above.
    \item $\ctclause{\Delta}{\Lambda_1 \setminus
        \{x\}}{\Gamma}{c_1 \langle a/x \rangle}{A_1}$ and
      $\ctclause{\Delta}{\Lambda_2 \setminus 
        \{x\}}{\Gamma}{c_2 \langle a/x \rangle}{A_2}$. This case cannot
      occur, since it would imply that $x \not\in \Lambda_1 \cup
      \Lambda_2$.
    \end{itemize}

    We have now shown that the typing derivation exists, and we must
    then show the equality
    \[
    \cdenclause{\cand{c_1 \langle a/x
        \rangle}{c_2 \langle a/x \rangle}}{\delta}{\lambda}{\gamma} =
    \cdenclause{\cand{c_1}{c_2}}{\delta}{\lambda[x
      \mapsto a]}{\gamma}.
    \]
    But this follows directly from the induction hypothesis and the
    compositionality of $\otimes$.

  \item \fbox{\scriptsize \AxiomC{$\Delta(f) = ((\type_1,\ldots,\type_m),n)$}
      \AxiomC{$\ctaexp{\Lambda}{(e_{a_1},\ldots,e_{a_n})}{A}$}
      \AxiomC{$\forall i \in \{1,\ldots,m\}. \ctexp{\Gamma}{e_i}{\type_i}$}
      \TrinaryInfC{$\ctclause{\Delta}{\Lambda}{\Gamma}{\cinstantiate{f}{e_1,\ldots,e_m}{e_{a_1},\ldots,e_{a_n}}}{A}$}
      \DisplayProof{}}
    
    Now, $\cinstantiate{f}{\vec{e}}{e_{a_1}, \ldots e_{a_n}} \langle
    a/x \rangle = \cinstantiate{f}{\vec{e}}{e_{a_1} \langle a/x
      \rangle, \ldots e_{a_n} \langle a/x \rangle}$, so in order to
    show the typing derivation, it suffices to show that
    \[
    \ctaexp{\Lambda \setminus \{x\}}{(e_{a_1} \langle a/x 
      \rangle, \ldots, e_{a_n} \langle a/x \rangle)}{A \cup \{a\}}.
    \]
    But this follows easily by induction on the typing derivation
    $\ctaexp{\Lambda}{(e_{a_1}, \ldots, e_{a_n})}{A}$ (utilizing the
    fact that $e_{a_i} = x$ for at least one $i$).
    In order to show the equality, we must show that
    \begin{align*}
      &\delta(f)(\cdenexp{e_1}{\gamma},\ldots,\cdenexp{e_m}{\gamma})(\cdenaexp{e_{a_1}
      \langle a/x \rangle}{\lambda},
      \ldots \cdenaexp{e_{a_n} \langle a/x \rangle}{\lambda}) =\\
      &\delta(f)(\cdenexp{e_1}{\gamma}, \ldots,
      \cdenexp{e_m}{\gamma})(\cdenaexp{e_{a_1}}{\lambda[x \mapsto a]},
      \ldots \cdenaexp{e_{a_n}}{\lambda[x \mapsto a]}),
    \end{align*}
    but this follows immediately from the definition of $\cdenaexp{\cdot}{}$.
  \end{itemize}
  \qed
\end{proof}

\refthm{lemma:cupdatesound}
\begin{proof}
  The proof is by induction on the derivation of $\cupdate{D}{t_0}{t}{c}{r}:$
  \begin{itemize}[]\itemsep=5pt
  \item \fbox{\scriptsize \AxiomC{}
      \UnaryInfC{$\cupdate{D}{t_0}{t}{\cempty}{\cempty}$}
      \DisplayProof{}}

    It follows immediately from the definition of
    $\cdenclause{\cdot}{}{}{}{}{}$ that
    $\cdenclause{\cempty}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace}
    = \cdenclause{\cempty}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\trace}$.

  \item \fbox{\scriptsize \AxiomC{$\cevald{e_d}{(n_1,n_2)}$}
      \AxiomC{$t-t_0 > n_1 + n_2$}
      \BinaryInfC{$\cupdate{D}{t_0}{t}{\catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c}}{(t_0+n_1+n_2,\{a\})}$}
      \DisplayProof{}}
    
    It follows from Lemma \ref{lemma:soundcompleteexp} that
    $\cdendexp{e_d}{\emptyset}{t_0} = [t_0 + n_1; t_0 + n_1 + n_2]$,
    and consequently $\trace = \emptytrace \lor \tracestart(\trace)
    \geq t > t_0 + n_1 + n_2$ implies that case (b) in the
    definition of $\cdenclause{\cdot}{}{}{}{}{}$ is active, i.e.,
    \[
    \cdenclause{\catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c}}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace}
    = \lift{(t_0+n_1+n_2,\{a\})},
    \]
    as required.

  \item \fbox{\scriptsize \AxiomC{$\begin{array}{c}
          \cevald{e_d}{(n_1,n_2)\\
            t-t_0 \leq n_1 + n_2
          \end{array}}$}
      \AxiomC{$\begin{array}{c}
          \\
          e_d' \equiv
          \cwithinafter{n_2-\max(0,t-t_0-n_1)}{\max(0,n_1-t+t_0)}\end{array}$}
      \BinaryInfC{$\cupdate{D}{t_0}{t}{\begin{array}{l}\catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c}}
          {\\\catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d'}{c[x+t-t_0/x]}\end{array}}$}
      \DisplayProof{}}

    Now, in order to show that
    \begin{align}
      &\cdenclause{\catomic{a}{k(\vec{x})}{x}{e}{e_d}{c}}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace}
      &=\label{lemma:cupdatesound1}\\
      &\cdenclause{\catomic{a}{k(\vec{x})}{x}{e}{e_d'}{c[x+t-t_0/x]}}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\trace},\notag
    \end{align}
    we must consider the three possible cases (in Figure
    \ref{fig:cdenclausecontract}) for the left hand side of the
    equality (\ref{lemma:cupdatesound1}). We will make use of the
    following equality:
    \begin{align}
      t_0 + n_1 + n_2 = t+\max(0,n_1-t+t_0) + n_2 -
      \max(0,t-t_0-n_1).\label{lemma:cupdatesound2}
    \end{align}
    \begin{itemize}
    \item[(a):] Now, $\trace =
      \event{t'}{a}{\emptychoice}{k(\vec{d})}\trace'$, $t' \in
      \cdendexp{e_d}{\emptyset}{t_0}$, and
      \begin{align*}
        &\cdenclause{\catomic{a}{k(\vec{x})}{x}{e}{e_d}{c}}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace}
        =\\
        &\cdenclause{c}{\cdencontext{D}}{\emptyset}{[\vec{x} \mapsto
          \vec{d},x \mapsto t'-t_0]}{(t'+1)}{\trace'}.
      \end{align*}
      It follows from Lemma \ref{lemma:soundcompleteexp} that $t_0 +
      n_1 \leq t' \leq t_0 + n_1 + n_2$, and since $t' \geq t$ we must
      have (using (\ref{lemma:cupdatesound2})) that
      \[
      t + \max(0,n_1-t-t_0) \leq t' \leq t + \max(0,n_1-t+t_0) + n_2 -
      \max(0,t-t_0-n_1),
      \]
      but via Lemma \ref{lemma:soundcompleteexp} this means that $t' \in
      \cdendexp{e_d'}{\emptyset}{t}$. Consequently, the right hand
      side of the equality (\ref{lemma:cupdatesound1}) is also case
      (a), so we must show that
      \begin{align*}
        &\cdenclause{c}{\cdencontext{D}}{\emptyset}{[\vec{x} \mapsto
          \vec{d},x \mapsto t'-t_0]}{(t'+1)}{\trace'} =\\
        &\cdenclause{c[x+t-t_0/x]}{\cdencontext{D}}{\emptyset}{[\vec{x} \mapsto
          \vec{d},x \mapsto t'-t]}{(t'+1)}{\trace'}.
      \end{align*}
      But this follows from Lemma \ref{lemma:substclause}, as
      \begin{align*}
        &\cdenclause{c[x+t-t_0/x]}{\cdencontext{D}}{\emptyset}{[\vec{x}
          \mapsto \vec{d},x \mapsto t'-t]}{(t'+1)}{\trace'} =\\
        &\cdenclause{c}{\cdencontext{D}}{\emptyset}{([\vec{x}
          \mapsto \vec{d},x \mapsto t'-t][x \mapsto
          t'-t+t-t_0])}{(t'+1)}{\trace'}\\
        &\cdenclause{c}{\cdencontext{D}}{\emptyset}{([\vec{x}
          \mapsto \vec{d},x \mapsto
          t'-t_0])}{(t'+1)}{\trace'}.
      \end{align*}

    \item[(b):] Now by Lemma \ref{lemma:soundcompleteexp} we have that
      $\cdendexp{e_d}{\emptyset}{t_0} = [t_0+n_1;t_0+n_1+n_2]$, and by
      assumption $\trace = \emptytrace \lor \tracestart(\trace) > t_0+n_1+n_2$, and
      \[
      \cdenclause{\catomic{a}{k(\vec{x})}{x}{e}{e_d}{c}}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace}
      = \lift{(t_0+n_1+n_2,\{a\})}.
      \]
      If $\trace = \emptytrace$, then the right hand side of the
      equality (\ref{lemma:cupdatesound1}) is also case (b), and if
      $\trace \neq \emptytrace$, then it follows from the assumption,
      $\tracestart(\trace) > t_0+n_1+n_2$, and
      (\ref{lemma:cupdatesound2}) that
      \[
      \tracestart(\trace) > t + \max(0,n_1-t+t_0) + n_2 -
      \max(0,t-t_0-n_1).
      \]
      Hence in both cases, the right hand side of the
      equality (\ref{lemma:cupdatesound1}) is case (b), i.e.,
      \begin{align*}
        &\cdenclause{\catomic{a}{k(\vec{x})}{x}{e}{e_d'}{c[x+t-t_0/x]}}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\trace} =\\
        &\lift{(t+\max(0,n_1-t+t_0) + n_2 - \max(0,t-t_0-n_1),\{a\})} =\\
        &\lift{(t_0+n_1+n_2,\{a\})},
      \end{align*}
      as required.

    \item[(c):] Now, $\trace =
      \event{t'}{a'}{\emptychoice}{k'(\vec{d})}\trace'$, and
      \[
      \cdenclause{\catomic{a}{k(\vec{x})}{x}{e}{e_d}{c}}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace}
      = \lift{(t',\{a\})}.
      \]
      It then again follows from Lemma \ref{lemma:soundcompleteexp}
      that the right hand side of the equality
      (\ref{lemma:cupdatesound1}) is case (c), i.e.,
      \[
        \cdenclause{\catomic{a}{k(\vec{x})}{x}{e}{e_d'}{c[x+t-t_0/x]}}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\trace} =
        \lift{(t',\{a\})}
      \]
      as required.
    \end{itemize}

  \item \fbox{\scriptsize \AxiomC{$\cevald{e_d}{(n_1,n_2)}$}
      \AxiomC{$t-t_0 > n_1 + n_2$}
      \AxiomC{$\cupdate{D}{t_0+n_1+n_1+1}{t}{c_2}{r}$}
      \TrinaryInfC{$\cupdate{D}{t_0}{t}{\catomicp{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}{r}$}
      \DisplayProof{}}

    It follows from Lemma \ref{lemma:soundcompleteexp} that
    $\cdendexp{e_d}{\emptyset}{t_0} = [t_0 + n_1; t_0 + n_1 + n_2]$,
    and consequently $\trace = \emptytrace \lor \tracestart(\trace)
    \geq t > t_0 + n_1 + n_2$ implies that case (b) in the
    definition of $\cdenclause{\cdot}{}{}{}{}{}$ is active, i.e.,
    \begin{align*}
      &\cdenclause{\catomicp{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace}
      =\\
      &\cdenclause{c_2}{\cdencontext{D}}{\emptyset}{\emptyset}{(t_0+n_1+n_2+1)}{\trace}.
    \end{align*}
    But then the result follows from the induction hypothesis ($c_2$
    is closed and well-typed, and $\trace = \emptytrace \lor
    \tracestart(\trace) \geq t_0 + n_1 + n_2 + 1$).

  \item \fbox{\scriptsize \AxiomC{$\begin{array}{c}
          \cevald{e_d}{(n_1,n_2)\\
            t-t_0 \leq n_1 + n_2
          \end{array}}$}
      \AxiomC{$\begin{array}{c}
          \\
          e_d' \equiv
          \cwithinafter{n_2-\max(0,t-t_0-n_1)}{\max(0,n_1-t+t_0)}\end{array}$}
      \BinaryInfC{$\cupdate{D}{t_0}{t}{\begin{array}{l}\catomicp{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}
          {\\\catomicp{\vec{a}}{k(\vec{x})}{x}{e}{e_d'}{c_1[x+t-t_0/x]}{c_2}\end{array}}$}
      \DisplayProof{}}

    Now, in order to show that
    \begin{align}
      &\cdenclause{\catomicp{a}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace}
      &=\notag\\
      &\cdenclause{\catomicp{a}{k(\vec{x})}{x}{e}{e_d'}{c_1[x+t-t_0/x]}{c_2}}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\trace},\label{lemma:cupdatesound3}
    \end{align}
    we must consider the three possible cases (in Figure
    \ref{fig:cdenclausecontract}) for the left hand side of the
    equality (\ref{lemma:cupdatesound3}). The cases (a') and (c') are
    identical with the cases (a) and (c) from earlier, so we only
    consider the case (b'):
 
    Now by Lemma \ref{lemma:soundcompleteexp} we have that
    $\cdendexp{e_d}{\emptyset}{t_0} = [t_0+n_1;t_0+n_1+n_2]$, and by
    assumption $\trace = \emptytrace \lor \tracestart(\trace) > t_0+n_1+n_2$, and
    \begin{align*}
      &\cdenclause{\catomicp{a}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace}
      =\\
      &\cdenclause{c_2}{\cdencontext{D}}{\emptyset}{\emptyset}{(t_0+n_1+n_2+1)}{\trace}.
    \end{align*}
    If $\trace = \emptytrace$, then the right hand side of the
    equality (\ref{lemma:cupdatesound3}) is also case (b'), and if
    $\trace \neq \emptytrace$, then it follows from the assumption,
    $\tracestart(\trace) > t_0+n_1+n_2$, and
    (\ref{lemma:cupdatesound2}) that
    \[
    \tracestart(\trace) > t + \max(0,n_1-t+t_0) + n_2 -
    \max(0,t-t_0-n_1).
    \]
    Hence in both cases, the right hand side of the
    equality (\ref{lemma:cupdatesound3}) is case (b'), i.e.,
    \begin{align*}
      &\cdenclause{\catomicp{a}{k(\vec{x})}{x}{e}{e_d'}{c_1[x+t-t_0/x]}{c_2}}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\trace}
      =\\
      &\cdenclause{c_2}{\cdencontext{D}}{\emptyset}{\emptyset}{(t_0+n_1+n_2+1)}{\trace},
   \end{align*}
    as required.

  \item \fbox{\scriptsize \AxiomC{$\cupdate{D}{t_0}{t}{c_1}{r_1}$}
      \AxiomC{$\cupdate{D}{t_0}{t}{c_2}{r_2}$}
      \BinaryInfC{$\cupdate{D}{t_0}{t}{\canddefault}{r_1 \owedge r_2}$}
      \DisplayProof{}}

    There are four cases (in the following, $\tracesplit(\trace) =
    (\trace_1,\trace_2)$):
    \begin{itemize}
    \item $r_1 = (t_1,B_2)$ and $r_2 = (t_2,B_2)$. Now, by the
      definition of $\owedge$ it follows that we must show that
      $\cdenclause{\canddefault}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace}
      = \lift{(t_1,B_1) \otimes (t_2,B_2)}$. But from the induction
      hypothesis it follows that
      $\cdenclause{c_1}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace_1}
      = \lift{(t_1,B_1)}$ and
      $\cdenclause{c_2}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace_2}
      = \lift{(t_2,B_2)}$, and the result hence follows from the
      definition of $\otimes_\bot$. (It also follows from the induction
      hypothesis that $\min(t_1,t_2) < t$.)
    \item $r_1 = (t_1,B_1)$ and $r_2 = c_2'$. Now, by the
      definition of $\owedge$ it follows that we must show that
      $\cdenclause{\canddefault}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace}
      = \lift{(t_1,B_1)}$. By the induction hypothesis it follows that
      $\cdenclause{c_1}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace_1}
      = \lift{(t_1,B_1)}$, $t_1 < t$, and
      $\cdenclause{c_2}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace_2}
      =
      \cdenclause{c_2'}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\trace_2}$. Now,
      $D$ is assumed to be guarded, so from Theorem
      \ref{theorem:guardedness} we get that 
      $\cdenclause{c_2'}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\trace_2}
      = \lift{\conforming}$, or
      $\cdenclause{c_2'}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\trace_2}
      = \lift{(t_2,B_2)}$. In the former case the result follows directly
      by the definition of $\otimes_\bot$, and in the latter case it
      follows from Corollary \ref{corollary:p} that $t_2 \geq
      t > t_1$, and consequently the result follows from the definition of
      $\otimes_\bot$.
    \item $r_1 = c_1'$ and $r_2 = (t_2,B_2)$. Analogous to the case
      above.
    \item $r_1 = c_1'$ and $r_2 = c_2'$. Now, $r_1 \owedge r_2 =
      \cand{c_1'}{c_2'}$, so the result follows from the induction
      hypothesis and the compositionality of $\otimes$.
    \end{itemize}
    
  \item \fbox{\scriptsize \AxiomC{$\cupdate{D}{t_0}{t}{c_1}{r_1}$}
      \AxiomC{$\cupdate{D}{t_0}{t}{c_2}{r_2}$}
      \BinaryInfC{$\cupdate{D}{t_0}{t}{\cordefault}{r_1 \ovee r_2}$}
      \DisplayProof{}}

    There are four cases:
    \begin{itemize}
    \item $r_1 = (t_1,B_2)$ and $r_2 = (t_2,B_2)$. Now, by the
      definition of $\ovee$ it follows that we must show that
      $\cdenclause{\cordefault}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}\trace
      = \lift{(t_1,B_1) \oplus (t_2,B_2)}$. But from the induction
      hypothesis it follows that
      $\cdenclause{c_1}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}\trace
      = \lift{(t_1,B_1)}$ and
      $\cdenclause{c_2}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}\trace
      = \lift{(t_2,B_2)}$, and the result hence follows from the
      definition of $\oplus_\bot$. (It also follows from the
      induction hypothesis that $\max(t_1,t_2) < t$.)
    \item $r_1 = (t_1,B_1)$ and $r_2 = c_2'$. Now, by the
      definition of $\ovee$ it follows that we must show that
      $\cdenclause{\cordefault}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}\trace 
      =
      \cdenclause{c_2'}{\cdencontext{D}}{\emptyset}{\emptyset}{t}\trace$. By
      the induction hypothesis it follows that 
      $\cdenclause{c_1}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}\trace
      = \lift{(t_1,B_1)}$, $t_1 < t$, and
      $\cdenclause{c_2}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}\trace
      =
      \cdenclause{c_2'}{\cdencontext{D}}{\emptyset}{\emptyset}{t}\trace$. 
      Now, $D$ is assumed to be guarded, so it follows from Theorem \ref
      {theorem:guardedness} that
      $\cdenclause{c_2'}{\cdencontext{D}}{\emptyset}{\emptyset}{t}\trace
      = \lift{\conforming}$, or
      $\cdenclause{c_2'}{\cdencontext{D}}{\emptyset}{\emptyset}{t}\trace
      = \lift{(t_2,B_2)}$. In the former case the result follows directly
      by the definition of $\oplus_\bot$, and in the latter case it
      follows from Corollary \ref{corollary:p} that $t_2 \geq
      t > t_1$, and consequently the result follows from the definition of
      $\oplus_\bot$.
    \item $r_1 = c_1'$ and $r_2 = (t_2,B_2)$. Analogous to the case
      above.
    \item $r_1 = c_1'$ and $r_2 = c_2'$. Now, $r_1 \ovee r_2 =
      \cand{c_1'}{c_2'}$, so the result follows from the induction
      hypothesis and the compositionality of $\oplus$.
    \end{itemize}

  \item \fbox{\scriptsize \AxiomC{$\ceval{e}{\ctrue}$}
      \AxiomC{$\cupdate{D}{t_0}{t}{c_1}{r_1}$}
      \BinaryInfC{$\cupdate{D}{t_0}{t}{\cifthenelsedefault}{r_1}$}
      \DisplayProof{}}

    Follows from the induction hypothesis and Lemma \ref{lemma:soundcompleteexp}.

  \item \fbox{\scriptsize \AxiomC{$\ceval{e}{\cfalse}$}
      \AxiomC{$\cupdate{D}{t_0}{t}{c_2}{r_2}$}
      \BinaryInfC{$\cupdate{D}{t_0}{t}{\cifthenelsedefault}{r_2}$}
      \DisplayProof{}}

    Follows from the induction hypothesis and Lemma \ref{lemma:soundcompleteexp}.

  \item \fbox{\scriptsize \AxiomC{$\ceval{\vec{e}}{\vec{d}}$}
      \AxiomC{$\cinstantiate{f}{\vec{x}}{\vec{y}} = c \in D$}
      \AxiomC{$\cupdate{D}{t_0}{t}{c[\vec{d}/\vec{x},\vec{a}/\vec{y}]\langle
          \vec{a}/\vec{y} \rangle}{r}$}
      \TrinaryInfC{$\cupdate{D}{t_0}{t}{\cinstantiate{f}{\vec{e}}{\vec{a}}}{r}$}
      \DisplayProof{}}

    Now, $\cdencontext{D}$ is the least fixed-point of the function
    $\Phi$ from Figure \ref{fig:cdenclausecontract}, which means that
    $\cdencontext{D}(f)(\vec{d})(\vec{a}) =
    \cdenclause{c}{\cdencontext{D}}{[\vec{y} \mapsto
      \vec{a}]}{[\vec{x} \mapsto \vec{d},\vec{y} \mapsto
      \vec{a}]}{}$. Hence
    \[
    \cdenclause{\cinstantiate{f}{\vec{e}}{\vec{a}}}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace}
    = 
    \cdenclause{c}{\cdencontext{D}}{[\vec{y} \mapsto
      \vec{a}]}{[\vec{x} \mapsto \cdenexp{\vec{e}}{\emptyset},\vec{y} \mapsto
      \vec{a}]}{t_0}{\trace},
    \]
    and it then follows from Lemma \ref{lemma:soundcompleteexp} and
    Lemma \ref{lemma:substclause} that
    \[
    \cdenclause{\cinstantiate{f}{\vec{e}}{\vec{a}}}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace}
    = 
    \cdenclause{c[\vec{d}/\vec{x},\vec{a}/\vec{y}]
      \langle \vec{a}/\vec{y} \rangle
    }{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace},
    \]
    where $\ceval{\vec{e}}{\vec{d}}$. But then the result follows from
    the induction hypothesis.
  \end{itemize}
  \qed
\end{proof}

\refthm{lemma:cstepsound}
\begin{proof}
  The proof is by induction on the derivation of
  $\cstep{D}{t_0}{c}{e}{r}$:
  \begin{itemize}[]\itemsep=5pt
  \item \fbox{ \scriptsize
      \AxiomC{$\ceval{e[\vec{d}/\vec{x}]}{\ctrue}$}
      \AxiomC{$\cevald{e_d}{(n_1,n_2)}$}
      \AxiomC{$n_1 \leq t-t_0 \leq n_1 + n_2$}
      \TrinaryInfC{$\cstep{D}{t_0}{\catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c}}{\event{t}{a}{\emptychoice}{k(\vec{d})}}{c[\vec{d}/\vec{x},t-t_0/x]}$}
      \DisplayProof{}}

    Now, by Lemma \ref{lemma:soundcompleteexp} it follows that
    $\cdendexp{e_d}{\emptyset}{t_0} = [t_0+n_1; t_0 + n_1 + n_2]$, and
    consequently $t \in \cdendexp{e_d}{\emptyset}{t_0}$. It also
    follows from Lemma \ref{lemma:soundcompleteexp}  and Lemma
    \ref{lemma:substexp} that $\cdenexp{e}{[\vec{x} \mapsto \vec{d}]} =
    \cdenexp{e[\vec{d}/\vec{x}]}{\emptyset} = \ctrue$, and hence by
    the definition of $\cdenclause{\cdot}{}{}{}{}{}$ (a) we have that
    \begin{align*}
    &\cdenclause{\catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c}}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
    =\\
    &\cdenclause{c}{\cdencontext{D}}{\emptyset}{[\vec{x} \mapsto
      \vec{d}, x \mapsto t-t_0]}{(t+1)}{\trace}.
    \end{align*}
    But then the result follows from Lemma
    \ref{lemma:substclause}.

  \item \fbox{\scriptsize \AxiomC{$\cevald{e_d}{(n_1,n_2)}$}
      \AxiomC{$t > t_0 + n_1 + n_2$}
      \BinaryInfC{$\cstep{D}{t_0}{\catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c}}{\event{t}{a'}{\choice}{k'(\vec{d}))}}{(t_0+n_1+n_2,\{a\})}$}
      \DisplayProof{}}

    Again, by Lemma \ref{lemma:soundcompleteexp} it follows that
    $\cdendexp{e_d}{\emptyset}{t_0} = [t_0+n_1; t_0 + n_1 + n_2]$, and
    consequently by the definition of $\cdenclause{\cdot}{}{}{}{}{}$
    (b) we have that
    \[
    \cdenclause{\catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c}}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
    =
    \lift{(t_0+n_1+n_2,\{a\})},
    \]
    as required.

  \item \fbox{\scriptsize \AxiomC{$a' \neq a \lor \choice \neq \emptychoice \lor k' \neq k
        \lor \ceval{e[\vec{d}/\vec{x}]}{\cfalse}$}
      \AxiomC{$\cevald{e_d}{(n_1,n_2)}$}
      \AxiomC{$t \leq t_0 + n_1 + n_2$}
      \TrinaryInfC{$\cstep{D}{t_0}{\catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c}}{\event{t}{a'}{\choice}{k'(\vec{d}))}}{(t,\{a'\})}$}
      \DisplayProof{}}

    Again, by Lemma \ref{lemma:soundcompleteexp} it follows that
    $\cdendexp{e_d}{\emptyset}{t_0} = [t_0+n_1; t_0 + n_1 + n_2]$, and
    consequently by the definition of $\cdenclause{\cdot}{}{}{}{}{}$
    (c) we have that
    \[
    \cdenclause{\catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c}}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
    =
    \lift{(t,\{a'\})},
    \]
    as required.

  \item \fbox{\scriptsize \AxiomC{$\ceval{e[\vec{d}/\vec{x}]}{\ctrue}$}
      \AxiomC{$\cevald{e_d}{(n_1,n_2)}$}
      \AxiomC{$n_1 \leq t-t_0 \leq n_1 + n_2$}
      \TrinaryInfC{$\cstep{D}{t_0}{\catomicp{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}{\event{t}{a}{\emptychoice}{k(\vec{d}))}}{c_1[\vec{d}/\vec{x},t-t_0/x]}$}
      \DisplayProof{}}

    Similar to the first case for $c \equiv \catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c}$.

  \item \fbox{\scriptsize \AxiomC{$\cevald{e_d}{(n_1,n_2)}$}
      \AxiomC{$t > t_0 + n_1 + n_2$}
      \AxiomC{$\cstep{D}{t_0+n_1+n_2+1}{c_2}{\event{t}{a'}{\choice}{k'(\vec{d}))}}{r}$}
      \TrinaryInfC{$\cstep{D}{t_0}{\catomicp{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}{\event{t}{a'}{\choice}{k'(\vec{d}))}}{r}$}
      \DisplayProof{}}

    Now, by Lemma \ref{lemma:soundcompleteexp} it follows that
    $\cdendexp{e_d}{\emptyset}{t_0} = [t_0+n_1; t_0 + n_1 + n_2]$, and
    consequently by the definition of $\cdenclause{\cdot}{}{}{}{}{}$
    (b') we have that
    \begin{align*}
      \cdenclause{\catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c}}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
      =\\
      \cdenclause{c_2}{\cdencontext{D}}{\emptyset}{\emptyset}{(t_0+n_1+n_2+1)}{(e\trace)}.
   \end{align*}
   But then the result follows from the induction hypothesis
   (the induction hypothesis is applicable, because $\tracestart(e\trace) = t \geq t_0 + n_1 + n_2 + 1$).

  \item \fbox{\scriptsize \AxiomC{$a' \neq a \lor \choice \neq \emptychoice \lor k' \neq k
        \lor \ceval{e[\vec{d}/\vec{x}]}{\cfalse}$}
      \AxiomC{$\cevald{e_d}{(n_1,n_2)}$}
      \AxiomC{$t \leq t_0 + n_1 + n_2$}
      \TrinaryInfC{$\cstep{D}{t_0}{\catomicp{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}{\event{t}{a'}{\choice}{k'(\vec{d}))}}{(t,\{a'\})}$}
      \DisplayProof{}}

    Similar to the third case for $c \equiv \catomic{\vec{a}}{k(\vec{x})}{x}{e}{e_d}{c}$.

  \item \fbox{\scriptsize \AxiomC{$\begin{array}{c}
          \vspace{5pt}
          \cstep{D}{t_0}{c_i}{\event{t}{a}{\choice'}{k(\vec{d})}}{r_i}\\
          \cupdate{D}{t_0}{t+1}{c_j}{r_j}
        \end{array}$}
      \AxiomC{$
        (i,j,\choice') = \left\{\begin{array}{ll}
            (1,2,\choice''), &\mbox{if }= \choice = l.\choice''\\
            (2,1,\choice''), &\mbox{if }= \choice = r.\choice''\\
            (2,1,\emptychoice), &\mbox{if }= \choice = \emptychoice
          \end{array}\right.$}
      \BinaryInfC{$\cstep{D}{t_0}{\canddefault}{\event{t}{a}{\choice}{k(\vec{d})}}{r_1
          \owedge r_2}$}
      \DisplayProof{}}

    Now, there are two cases, so consider the case where
    \[
    \cstep{D}{t_0}{c_1}{\event{t}{a}{\choice'}{k(\vec{d})}}{r_1}
    \qquad\mbox{ and }\qquad
    \cupdate{D}{t_0}{t+1}{c_2}{r_2}.
    \]
    (The other case is symmetric.) There are four cases (in the
    following, $\tracesplit(\trace) = (\trace_1,\trace_2)$):
    \begin{itemize}
    \item $r_1 = (t_1,B_2)$ and $r_2 = (t_2,B_2)$. Now, by the
      definition of $\owedge$ it follows that we must show that
      $\cdenclause{\canddefault}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
      = \lift{(t_1,B_1) \otimes (t_2,B_2)}$. It first follows from the induction
      hypothesis that
      $\cdenclause{c_1}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace_1)}
      = \lift{(t_1,B_1)}$, and then from Lemma
      \ref{lemma:cupdatesound} that
      $\cdenclause{c_2}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace_2}
      = \lift{(t_2,B_2)}$. (Lemma \ref{lemma:cupdatesound} applies,
      since if $\trace_2 \neq \emptytrace$, then
      $\tracestart(\trace_2) \geq t+1 > t$, as the time stamps are
      increasing in event traces.) But then the result follows from the
      definition of $\otimes_\bot$.
    \item $r_1 = (t_1,B_1)$ and $r_2 = c_2'$. Now, by the
      definition of $\owedge$ it follows that we must show that
      $\cdenclause{\canddefault}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
      = \lift{(t_1,B_1)}$. By the induction hypothesis it follows that
      $\cdenclause{c_1}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace_1)}
      = \lift{(t_1,B_1)}$, $t_1 \leq t$, and by Lemma
      \ref{lemma:cupdatesound} that
      $\cdenclause{c_2}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace_2}
      =
      \cdenclause{c_2'}{\cdencontext{D}}{\emptyset}{\emptyset}{(t+1)}{\trace_2}$.
      Now, $D$ is assumed to be guarded, so it follows from Theorem \ref
      {theorem:guardedness} that
      $\cdenclause{c_2'}{\cdencontext{D}}{\emptyset}{\emptyset}{(t+1)}\trace
      = \lift{\conforming}$, or
      $\cdenclause{c_2'}{\cdencontext{D}}{\emptyset}{\emptyset}{(t+1)}\trace
      = \lift{(t_2,B_2)}$. In the former case the result follows directly
      by the definition of $\otimes_\bot$, and in the latter case it
      follows from Corollary \ref{corollary:p} that $t_2 \geq
      t+1 > t_1$, and consequently the result follows from the definition of
      $\otimes_\bot$.
    \item $r_1 = c_1'$ and $r_2 = (t_2,B_2)$. Now, by the
      definition of $\owedge$ it follows that we must show that
      $\cdenclause{\canddefault}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
      = \lift{(t_2,B_2)}$. By the induction hypothesis it follows that
      $\cdenclause{c_1}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace_1)} =
      \cdenclause{c_1'}{\cdencontext{D}}{\emptyset}{\emptyset}{(t+1)}{\trace_1}$,
      and by Lemma \ref{lemma:cupdatesound} that
      $\cdenclause{c_2}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace_2}
      = \lift{(t_2,B_2)}$, and $t_2 < t$.
      Now, $D$ is assumed to be guarded, so it follows from Theorem \ref
      {theorem:guardedness} that
      $\cdenclause{c_1'}{\cdencontext{D}}{\emptyset}{\emptyset}{(t+1)}{\trace}
      = \lift{\conforming}$, or
      $\cdenclause{c_1'}{\cdencontext{D}}{\emptyset}{\emptyset}{(t+1)}{\trace}
      = \lift{(t_1,B_1)}$. In the former case the result follows directly
      by the definition of $\otimes_\bot$, and in the latter case it
      follows from Corollary \ref{corollary:p} that $t_1 \geq
      t+1 > t_2$, and consequently the result follows from the definition of
      $\otimes_\bot$.
    \item $r_1 = c_1'$ and $r_2 = c_2'$. Now, by the
      definition of $\owedge$ it follows that we must show that
      $\cdenclause{\canddefault}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
      =
      \cdenclause{\cand{c_1'}{c_2'}}{\cdencontext{D}}{\emptyset}{\emptyset}{(t+1)}{\trace}$. By
      the induction hypothesis it follows that 
      $\cdenclause{c_1}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace_1)} =
      \cdenclause{c_1'}{\cdencontext{D}}{\emptyset}{\emptyset}{(t+1)}{\trace_1}$,
      and by Lemma \ref{lemma:cupdatesound} that
      $\cdenclause{c_2}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{\trace_2}
      =
      \cdenclause{c_2'}{\cdencontext{D}}{\emptyset}{\emptyset}{(t+1)}{\trace_2}$. But
      then the result follows directly from the definition of $\otimes_\bot$.
    \end{itemize}

  \item \fbox{\scriptsize \AxiomC{$\cupdate{D}{t_0}{t}{c_1}{r_1}$}
      \AxiomC{$\cupdate{D}{t_0}{t}{c_2}{r_2}$}
      \BinaryInfC{$\cupdate{D}{t_0}{t}{\cordefault}{r_1 \ovee r_2}$}
      \DisplayProof{}}
    
    There are four cases:
    \begin{itemize}
    \item $r_1 = (t_1,B_2)$ and $r_2 = (t_2,B_2)$. Now, by the
      definition of $\ovee$ it follows that we must show that
      $\cdenclause{\cordefault}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
      = \lift{(t_1,B_1) \lor (t_2,B_2)}$. It follows from the induction
      hypothesis that
      $\cdenclause{c_1}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
      = \lift{(t_1,B_1)}$, and
      $\cdenclause{c_2}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
      = \lift{(t_2,B_2)}$, and consequently the result follows from
      the definition of $\oplus_\bot$.
    \item $r_1 = (t_1,B_1)$ and $r_2 = c_2'$. Now, by the
      definition of $\ovee$ it follows that we must show that
      $\cdenclause{\cordefault}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
      = \lift{(t_1,B_1)}$. By the induction hypothesis it follows that
      $\cdenclause{c_1}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
      = \lift{(t_1,B_1)}$, $t_1 \leq t$, and
      $\cdenclause{c_2}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
      = \cdenclause{c_2'}{\cdencontext{D}}{\emptyset}{\emptyset}{(t+1)}{\trace}$.
      Now, $D$ is assumed to be guarded, so it follows from Theorem \ref
      {theorem:guardedness} that
      $\cdenclause{c_2'}{\cdencontext{D}}{\emptyset}{\emptyset}{(t+1)}{\trace}
      = \lift{\conforming}$, or
      $\cdenclause{c_2'}{\cdencontext{D}}{\emptyset}{\emptyset}{(t+1)}{\trace}
      = \lift{(t_2,B_2)}$. In the former case the result follows directly
      by the definition of $\oplus_\bot$, and in the latter case it
      follows from Corollary \ref{corollary:p} that $t_2 \geq
      t+1 > t_1$, and consequently the result follows from the definition of
      $\oplus_\bot$.
    \item $r_1 = c_1'$ and $r_2 = (t_2,B_2)$. Similar to the case above.
    \item $r_1 = c_1'$ and $r_2 = c_2'$. Now, by the
      definition of $\ovee$ it follows that we must show that
      $\cdenclause{\cordefault}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
      =
      \cdenclause{\cor{c_1'}{c_2'}}{\cdencontext{D}}{\emptyset}{\emptyset}{(t+1)}{\trace}$. By
      the induction hypothesis it follows that 
      $\cdenclause{c_1}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)} =
      \cdenclause{c_1'}{\cdencontext{D}}{\emptyset}{\emptyset}{(t+1)}{\trace}$,
      and
      $\cdenclause{c_2}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
      =
      \cdenclause{c_2'}{\cdencontext{D}}{\emptyset}{\emptyset}{(t+1)}{\trace}$,
      and consequently the result follows from the definition of $\oplus_\bot$.
    \end{itemize}

  \item \fbox{\scriptsize \AxiomC{$\ceval{e}{\ctrue}$}
      \AxiomC{$\cstep{D}{t}{c_1}{e}{r_1}$}
      \BinaryInfC{$\cstep{D}{t}{\cifthenelsedefault}{e}{r_1}$}
      \DisplayProof{}}

    The result follows immediately from the induction hypothesis and
    Lemma \ref{lemma:soundcompleteexp}.
    
  \item \fbox{\scriptsize \AxiomC{$\ceval{e}{\cfalse}$}
      \AxiomC{$\cstep{D}{t}{c_2}{e}{r_2}$}
      \BinaryInfC{$\cstep{D}{}{\cifthenelsedefault}{e}{r_2}$}
      \DisplayProof{}}

    The result follows immediately from the induction hypothesis and
    Lemma \ref{lemma:soundcompleteexp}.

  \item \fbox{\scriptsize \AxiomC{$\ceval{\vec{e}}{\vec{d}}$}
      \AxiomC{$\cinstantiate{f}{\vec{x}}{\vec{y}} = c \in D$}
      \AxiomC{$\cstep{D}{t}{c[\vec{d}/\vec{x},\vec{a}/\vec{y}]\langle
          \vec{a}/\vec{y} \rangle}{e}{r}$}
      \TrinaryInfC{$\cstep{D}{t}{\cinstantiate{f}{\vec{e}}{\vec{a}}}{e}{r}$}
      \DisplayProof{}}

    Now, as in the proof of Lemma \ref{lemma:cupdatesound}, we have
    that
    \[
    \cdenclause{\cinstantiate{f}{\vec{e}}{\vec{a}}}{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}
    = 
    \cdenclause{c[\vec{d}/\vec{x},\vec{a}/\vec{y}]
      \langle \vec{a}/\vec{y} \rangle
    }{\cdencontext{D}}{\emptyset}{\emptyset}{t_0}{(e\trace)}.
    \]
    But then the result follows from the induction hypothesis.
  \end{itemize}
  \qed
\end{proof}

\refthm{lemma:cnullablesound}
\begin{proof}
  ``$\Rightarrow$'': By induction on the derivation of
  $\cnullable{D}{c}$:
  \begin{itemize}[]\itemsep=5pt
  \item \fbox{\scriptsize \AxiomC{}
      \UnaryInfC{$\cnullable{D}{\cempty}$}
      \DisplayProof{}}

    Follows immediately from the definition of
    $\cdenclause{\cdot}{}{}{}{}{}$.

  \item \fbox{\scriptsize \AxiomC{$\cnullable{D}{c_1}$}
      \AxiomC{$\cnullable{D}{c_2}$}
      \BinaryInfC{$\cnullable{D}{\canddefault}$}
      \DisplayProof{}}

    Follows from the induction hypothesis and the definition of $\otimes_\bot$.

  \item \fbox{\scriptsize \AxiomC{$\cnullable{D}{c_1}$}
      \UnaryInfC{$\cnullable{D}{\cordefault}$}
      \DisplayProof{}}

   Follows from the induction hypothesis and the definition of $\oplus_\bot$.

  \item \fbox{\scriptsize \AxiomC{$\cnullable{D}{c_2}$}
      \UnaryInfC{$\cnullable{D}{\cordefault}$}
      \DisplayProof{}}

    Follows from the induction hypothesis and the definition of $\oplus_\bot$.

  \item \fbox{\scriptsize \AxiomC{$\ceval{e}{\ctrue}$}
      \AxiomC{$\cnullable{D}{c_1}$}
      \BinaryInfC{$\cnullable{D}{\cifthenelsedefault}$}
      \DisplayProof{}}

    Follows from the induction hypothesis, the definition of
    $\cdenclause{\cdot}{}{}{}{}{}$, and Lemma \ref{lemma:soundcompleteexp}.

  \item \fbox{\scriptsize \AxiomC{$\ceval{e}{\cfalse}$}
      \AxiomC{$\cnullable{D}{c_2}$}
      \BinaryInfC{$\cnullable{D}{\cifthenelsedefault}$}
      \DisplayProof{}}

    Follows from the induction hypothesis, the definition of
    $\cdenclause{\cdot}{}{}{}{}{}$, and Lemma \ref{lemma:soundcompleteexp}.

  \item \fbox{\scriptsize \AxiomC{$\ceval{\vec{e}}{\vec{d}}$}
      \AxiomC{$\cinstantiate{f}{\vec{x}}{\vec{y}} = c \in D$}
      \AxiomC{$\cnullable{D}{c[\vec{d}/\vec{x},\vec{a}/\vec{y}]\langle
          \vec{a}/\vec{y} \rangle}$}
      \TrinaryInfC{$\cnullable{D}{\cinstantiate{f}{\vec{e}}{\vec{a}}}$}
      \DisplayProof{}}

    As in the proof of Lemma \ref{lemma:cupdatesound}, we have
    that
    \[
    \cdenclause{\cinstantiate{f}{\vec{e}}{\vec{a}}}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\emptytrace}
    = 
    \cdenclause{c[\vec{d}/\vec{x},\vec{a}/\vec{y}]
      \langle \vec{a}/\vec{y} \rangle
    }{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\emptytrace},
    \]
    but then the result follows from the induction hypothesis.
  \end{itemize}


  ``$\Leftarrow$'': We use Lemma \ref{lemma:guardednessbyconstruction}
  to construct a derivation, $\cguarded{D}{\emptyset}{c}$. The result
  is then shown by induction on this derivation:
  \begin{itemize}[]\itemsep=5pt
  \item \fbox{\scriptsize \AxiomC{$\cguarded{D}{\emptyset}{\cempty}$}
      \DisplayProof{}}

    Follows immediately.

  \item \fbox{\scriptsize \AxiomC{$\cguarded{D}{\emptyset}{\catomic{a}{k(\vec{x})}{x}{e}{e_d}{c}}$}
      \DisplayProof{}}

    This case cannot occur, since
    \[
    \cdenclause{\catomic{a}{k(\vec{x})}{x}{e}{e_d}{c}}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\emptytrace}
    \neq \lift{\conforming}.
    \]

  \item \fbox{\scriptsize
      \AxiomC{$\cguarded{D}{\emptyset}{c_2}$}
      \UnaryInfC{$\cguarded{D}{\emptyset}{\catomicp{\vec{e_a}}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}$}
      \DisplayProof{}}
    
    Now we must have that
    \begin{align*}
    &\cdenclause{\catomicp{a}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\emptytrace} &=\\
    &\cdenclause{c_2}{\cdencontext{D}}{\emptyset}{\emptyset}{(t_2+1)}{\emptytrace}
    &=\\
    &\lift{\conforming}.
    \end{align*}
    But then it follows from the induction hypothesis that
    $\cnullable{D}{c_2}$, and hence
    $\cnullable{D}{\catomicp{a}{k(\vec{x})}{x}{e}{e_d}{c_1}{c_2}}$.

  \item \fbox{\scriptsize \AxiomC{$\cguarded{D}{\emptyset}{c_1}$}
      \AxiomC{$\cguarded{D}{\emptyset}{c_2}$}
      \BinaryInfC{$\cguarded{D}{\emptyset}{\canddefault}$}
      \DisplayProof{}}

    Now,
    $\cdenclause{\canddefault}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\emptytrace}
    = \lift{\conforming}$, and hence from the definition of
    $\otimes_\bot$ it follows that
    $\cdenclause{c_1}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\emptytrace}
    = \cdenclause{c_2}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\emptytrace}
    = \lift{\conforming}$. But then the result follows from the
    induction hypothesis.

  \item \fbox{\scriptsize \AxiomC{$\cguarded{D}{\emptyset}{c_1}$}
      \AxiomC{$\cguarded{D}{\emptyset}{c_2}$}
      \BinaryInfC{$\cguarded{D}{\emptyset}{\cordefault}$}
      \DisplayProof{}}

    Now,
    $\cdenclause{\cordefault}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\emptytrace}
    = \lift{\conforming}$, and hence from the definition of
    $\oplus_\bot$ it follows that
    $\cdenclause{c_1}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\emptytrace}
    =  \lift{\conforming}$ or
    $\cdenclause{c_2}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\emptytrace} 
    = \lift{\conforming}$. But then the result follows from the
    induction hypothesis.

  \item \fbox{\scriptsize \AxiomC{$\cguarded{D}{\emptyset}{c_1}$}
      \AxiomC{$\cguarded{D}{\emptyset}{c_2}$}
      \BinaryInfC{$\cguarded{D}{\emptyset}{\cifthenelsedefault}$}
      \DisplayProof{}}

    Follows from the induction hypothesis, the definition of
    $\cdenclause{\cdot}{}{}{}{}{}$, and Lemma \ref{lemma:soundcompleteexp}.
    
  \item \fbox{\scriptsize \AxiomC{$f \not\in \emptyset$}
      \AxiomC{$\cinstantiate{f}{\vec{x}}{\vec{y}} = c \in D$}
      \AxiomC{$\cguarded{D}{\{f\}}{c}$}
      \TrinaryInfC{$\cguarded{D}{\emptyset}{\cinstantiate{f}{\vec{e}}{\vec{e_a}}}$}
      \DisplayProof{}}

    As in the proof of Lemma \ref{lemma:cupdatesound}, we have
    that
    \[
    \cdenclause{\cinstantiate{f}{\vec{e}}{\vec{a}}}{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\emptytrace}
    = 
    \cdenclause{c[\vec{d}/\vec{x},\vec{a}/\vec{y}]
      \langle \vec{a}/\vec{y} \rangle
    }{\cdencontext{D}}{\emptyset}{\emptyset}{t}{\emptytrace} = \lift{\conforming},
    \]
    but then the result follows from the induction hypothesis.  (Strictly speaking, we need a derivation of $\cguarded{D}{\{f\}}{c[\vec{d}/\vec{x},\vec{a}/\vec{y}]
      \langle \vec{a}/\vec{y} \rangle}$, but it is easy to construct
    such a derivation --- of the same size --- from the derivation,
    $\cguarded{D}{\{f\}}{c}$.)
  \end{itemize}
  \qed
\end{proof}

\end{document}