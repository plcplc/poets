\documentclass[10pt,a4paper,final,oneside,openany,article]{memoir}
\usepackage[utf8]{inputenc}
\usepackage[danish, british]{babel}
%\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{url}
\usepackage{listings}
\usepackage[draft]{fixme}
\usepackage{amsmath}
%\usepackage[ntheorem, overload]{empheq}
\usepackage{semantic}
\usepackage{color}

% Fonts configuration
%  - Palatino and Bitstream Vera Sans Mono for verbatim
\usepackage[T1]{fontenc}
\usepackage{palatino}
\usepackage[sc]{mathpazo} % Math font for Palatino
\usepackage{bera}
\linespread{1.05} % Palatino needs more leading (space between lines)
\usepackage{microtype} % ++

% Commands
\newcommand{\twofig}[6]{
\begin{figure}[htp!]
\begin{center}
\fbox{    \subfigure[#1]{    \includegraphics[width=0.4\textwidth]{#2}}
    \subfigure[#3]{    \includegraphics[width=0.4\textwidth]{#4}    } }
\caption{#5}
\label{#6}
\end{center}
\end{figure}
}

\newcommand{\onefig}[4]{
\begin{figure}[htp!]
\begin{center}
\fbox{    \includegraphics[width= #4 \textwidth]{#1}}
\caption{#2}
\label{#3}
\end{center}
\end{figure}
}

\mathlig{||}{\ |\ }

\newcommand{\kw}[1]{\text{\lstinline{#1}}}
\newcommand*\widefbox[1]{\fbox{\hspace{1em}#1\hspace{1em}}}

% Bibliography
\usepackage[style=alphabetic,natbib=true]{biblatex}
\bibliography{../bibliography}

\definecolor{kugrey}{rgb}{.4,.4,.4}

% Language syntax highlighting
\lstdefinelanguage{CSL}{ keywords={contract, true, false, if, then,
    else, where, due, immediately, within, after, or, and, andalso,
    empty, fun, val},
  keywordstyle = \textbf,
  commentstyle = \color{kugrey}\textit,
  stringstyle = \ttfamily,
  basicstyle   = \small\ttfamily,
  numberstyle=\tiny,
  sensitive = true,
  morecomment=[s]{/*}{*/},
  morecomment = [l]{//}
}
\lstset{language = CSL}

% Document meta
\title{Extending the POETS \\ Contract Specification Language\\
       \vspace{0.1cm}
        \small{A Summer of POETS Coding Extravaganza}}
\author{Philip Lykke Carlsen (plcplc@gmail.com) \and
        Martin Dybdal (dybber@dybber.dk) \and
        Brian Søborg Mathiasen (soborg@diku.dk)}
\date{27th August 2010}

% Layouting
\setcounter{tocdepth}{3}
\pagestyle{plain}
\setcounter{secnumdepth}{1}

\begin{document}
\listoffixmes
\fxnote{Kalder vi det expression language eller predicate language?}

\newpage
\maketitle

\chapter{Formalities}
This report was written as part of the DIKU course ``POETS Summer of
Code'' and presents a set of extensions to contract specification
language of the POETS\footnote{POETS abbreviates Process-Oriented
  Event-driven Transaction Systems} platform. The project was
supervised by Tom Hvitved and our code is available in the default
branch of the POETS Mercurial repository. Together with this report we
have handed in a Haddock documentation for POETS system.

\chapter{Introduction}
Recently, Tom Hvitved presented a language for specifying multi-party
contracts \cite{hvitved10} as part of the 3gERP and POETS projects
\cite{3gerp}. The \textit{Contract Specification Language},
\textit{CSL} makes it possible to write down sets of commitments
between several parties (e.g. individuals and companies) and combining
those commitments into legally binding agreements,
\textit{contracts}. The language overcomes a number of limitations in
earlier defined contract languages, for example blame assignment and
support for both relative and absolute temporal constraints.

The language is structured around \textit{clauses} which are combined
into \textit{contract templates} by a set of provided
combinators. These templates can then be instantiated in the running
system. For example a company might describe a sale of goods as a
contract template and when a specific article is sold, this contract
template is instantiated. Clauses describes the actions that certain
\textit{agents} (contract parties, e.g. a company) should perform and
also contains information about when this should happen (e.g., a
package must be dispatched within 10 days) and a predicate detailing
which constraints should be satisfied (e.g. a customer should transfer
the agreed amount of money). This predicate language (which we often
will call ``the CSL expression language'') was very limited in Tom
Hvitveds incarnation. For instance, while CSL supports lists, the
predicate language had no primitives for manipulating them and
provides no means of defining important abstractions, like functions.

We have extended the predicate language of CSL, on the basis of a
number of contract schemes of practical use, that were impossible to
formulate with the previous version of the language. The extensions
ensure the integrity of the core features of the language described in
\cite{hvitved10}.  In Section \ref{extensions} we will go through the
limitations of the current language that we want to solve. In Section
we will determine the syntax and semantics of these extensions should
be. Section
\ref{implementation} describes how we have implemented the
extensions.

\chapter{Extensions}
\label{extensions}
In this section we will go through the extensions CSL that we have
selected to implement and at the same time motivate these extensions
by describing contracts that could occur in real world applications of
the language.

\paragraph{Case 1: Manipulating lists} In the existing language it was
impossible to modify the contents of lists in any way. The only
available operations on lists were computing its length and comparison
operations. The language thus needs more general combinators for
performing list manipulations.

An example of a contract that could not be written in the previous
language incarnation, is a sales contract where the order is delivered
in several parcels. When the first parcel is received, the contract
should be updated to reflect that seller only needs to deliver the
remaining articles of the order.  We show how this could be
implemented with our extensions in Appendix
\ref{chap:sale_partial_delivery}.

\paragraph{Case 2: Abstractions and polymorphism} The current language
does not provide any way of writing functions on the expression
level. Contracts and clause templates provides abstraction on
syntactical hierarchy above. Clause templates could be used for for
some amount of code-reuse and abstractions, but it would not be
worthwhile. Functions are important abstractions in all modern
languages and without them code maintenance can become complicated. It
is basic knowledge that code duplication should be avoided.
Furthermore, functions should be as general as possible. It should not
be necessary to restrict a length function for lists to only work on
lists of e.g. integers. We thus want ML-style parametric polymorphism
in our language..

Our example in Appendix \ref{chap:sale_partial_delivery} also
illustrates the usefulness of functions for code reuse.

\paragraph{Case 3: Conditional expression.} Decisions can not be taken
on the expression level, only decisions that selects between several
clauses can be taken. Clause-level conditionals could be used for
implementing certain conditions, but for many applications they would
add an amount of repetition that wouldn't be needed with expression
level conditionals. 

As a very simple example of the usefulness of expression-level
conditionals, it should be noted that the minimum function could not
be expressed in the original language and was previously a hardcoded
primitive in the expression evaluator.

\chapter{Selecting language primitives}
In this section we analyse which language primitives we need to
overcomes the problems described in the above mentioned cases of
Section \ref{extensions}. It is desirable to restrict the amount of
language built-in primitives to a minimum, to limit implementation
complexity. 

\paragraph{Case 1: List manipulation}
A need of list manipulations implies a need of iteration or recursion
primitives. We could implement recursive functions along with head,
tail and cons to enable very minimal set of primitives, but we could
can not allow recursion. This would break \ldots \fxwarning{why again}.
Instead we need a way of iterating through lists while still
guarenteeing that all expressions will terminate.  Our solution to
this problem is simple: we provide three functions known from
functional languages for iterating through and manipulate lists. In
particular, we have implemented \lstinline{foldl}, \lstinline{foldr}
and \lstinline{cons} as built-in functions, which allows the user to
write the large array of functions expressible with these primitives.

\paragraph{Case 2: Functions} As CSL is a declarative language, our
functions should be inspired by declarative principles. We therefore
draw from the world of functional programming and define functions as
lambda expressions that acts as primitive values which can be passed
between other functions (higher-order functions). An important
limitation on expression-level functions is the above mentioned
limitation of terminating functions. If we were to allow recursive
functions, we would never be sure whether they would terminate and
this would break \ldots %with one of the main principles of CSL
\fxwarning{citation needed}.
% Limitation: no recursion and why?

\paragraph{Case 3: Conditional expressions}
Expression level conditionals are common features of all functional
languages and thus we simply adopt the notation and semantics from
such languages.


\chapter{Implementation}
\label{implementation}
\section{Syntactic extensions}
\begin{figure}
  \begin{align*}%[box=\widefbox]
    p ::= &~ \ldots || \kw{val}~ id : type = e \tag{CSL terms} \\
       & \quad\quad || \kw{fun}~ id : type~ (id_1 : type_1, id_2 : type_2, \ldots, id_n : type_n) = e  \\
    e ::= &~ \ldots || \lambda id_1~ id_2~ \ldots~ id_n -> e || e_1\ e_2  \tag{CSL predicates}\\
       & \quad\quad || \kw{if}~ c~ \kw{then}~ e_1~ \kw{else}~ e_2 \\ 
    type ::= &~ \ldots || type_1 -> type_2 ||
    typevar \tag{CSL types}
  \end{align*}
  \caption{Our extensions to the CSL grammar}
\label{fig:bnf}
\end{figure}

The grammar of the complete language is defined in the tech report by
Tom Hvitved \cite[page 13, Figure 1]{hvitved10}, our extensions can be seen in
Figure \ref{fig:bnf}. 

We have extended the set of CSL terms $p$ to include \textit{value}
and \textit{function definitions}.  As can be seen, our only syntactic
extensions to the CSL expression language (nonterminal $e$) are lambda
expressions, function application and conditional
expressions\footnote{Actually, negation is also our addition. It
  existed only by coincidence in the previous version.} %negationaddition
The multi
parametered expressions unfold to several embedded lambda expressions
and a function definition unfold to a value definition of a lambda
expression.

Type expressions are extended with function types and type
variables.

These extensions are made to the
\texttt{Poets.Contracts.Language.CSL.Parser} module of Poets. The most
interesting extensions are function application which are implemented
as a left-associative operator and \ldots.  \fxwarning{Haddock links
  to Parser and function application parsing}

\section{Built-in functions}
As a major motivation, in introducing function expressions through
syntax, was to eliminate the previously built-in list primitives,
\lstinline{max} and \lstinline{min}, we also introduced an explicit
requirement of being able to specify exactly those functions throug
other means. Thus we had to implement a small array of super-primitives,
with which we through the extended expression syntax could specify the
mentioned primitives. Implementing \lstinline{fold}'s as the
super-primitives would not only ensure that we are able to express 
\lstinline{max} and \lstinline{min}, but also be able to introduce more
advanced functions, such as \lstinline{map}, \lstinline{length} and so 
forth; in addition also ensure that the need for recursive operations
in expressions are kept at an absolute minimum.

\section{Type Inference}
The CSL implementation of Tom Hvitved already included support for
type variables, parametric polymorphism and also subtyping
polymorphism, but had to be extended to include function types.

We have extended the type inference algebra for CSL expressions to
include the constraints generated by the three typing
rules shown in Figure \ref{fig:typing_rules}. The typing rules of the
original language is found at \cite[page 17, Figure 3]{hvitved10}.  

In addition we have extended the default typing environment $\Gamma$
to include the types of our four built-in functions:
\lstinline{foldl}, \lstinline{foldr}, \lstinline{cons} and
\lstinline{ceil}.
\begin{figure}
  \begin{equation*}
    \frac{
      \Gamma |- c_1 : ~\kw{Bool}
      \quad \Gamma |- e_1 : \tau_1
      \quad \Gamma |- e_1 : \tau_2
    }{
      \Gamma |- \kw{if}~ c_1 ~\kw{then}~ e_1 ~\kw{else}~ e_2 : \tau_1
    }(\tau_1=\tau_2)\label{eq:type_cond}
  \end{equation*}

\begin{equation*}
  \frac{
    \Gamma\{id : \tau_1\} |- e : \tau_2
  }{
    \Gamma |- \lambda id -> e : \tau_1 -> \tau_2
  }
  \quad \quad 
  \frac{
    \Gamma |- e_1 : \tau_1 -> \tau_2
    \quad \Gamma |- e_2 : \tau_1
  }{
    \Gamma |- e_1~ e_2 : \tau_2
  }\label{eq:type_apply}
\end{equation*}

\caption{Typing rules for the extended language}
\label{fig:typing_rules}
\end{figure}
As the current type inference was developed by Tom Hvitved while we
were working on the project, it is still not completely
functional. Specifically, the constraint solver for the CSL type
inferer is yet to be implemented. This means that we have not been
able to test whether our generated constraints are correct and whether
they suffice to perform the inference. We thus can not give any
guarentees on the implemented functionality of this part.

% These rules ensure that it is impossible to make recursive functions
% by writing fix-point combinators. 

\section{Type Checking}
We had to extend the type checker to also type check the bound
variables. This is done by type checking the definitions in sequential
order of their appearence in a file, extending the typing environment
when each definition has been processed. This ensures that it is
impossible to make self-referencing, and thereby recursive, definitions.
This also includes mutually recursive definitions.

\section{Evaluating expressions}
An important addition to the evaluation algebra in CSL is the use of
environments. We have extended the evaluator monad with an environment
and pass this along where appropriate. The need for an environment is
facilitated by the lambda abstraction, this also means the semantics
of the expression evaluation is extended with this environment, while
only utilized by the lambda evaluation algebra instance. Thus, the
semantics of the extended language are as illustrated in Figure
\ref{fig:bigstep_semantics}.

\begin{figure}
\begin{equation*}
\frac{
  \sigma |- b \Downarrow \kw{false}
  \quad \sigma |- c_2 \Downarrow v_2
}{
  \sigma |- \kw{if} ~b ~\kw{then} ~c_1 ~\kw{else} ~c_2 \Downarrow v_2
}
\quad \quad
\frac{
  \sigma |- b \Downarrow \kw{true}
  \quad \sigma |- c_1 \Downarrow v_1
}{
  \sigma |- \kw{if} ~b ~\kw{then} ~c_1 ~\kw{else} ~c_2 \Downarrow v_1
}\label{eq:eval_condition}
\end{equation*}

\begin{equation*}
\frac{
  \sigma |- e_1 \Downarrow \lambda x \rightarrow e_3
  \quad \sigma |- e_2 \Downarrow v_1
  \quad \sigma[x\mapsto v_1] |- e_3 \Downarrow v_2
}{
  \sigma |- e_1 ~e_2 \Downarrow v_2
}\label{eq:eval_apply}
\end{equation*}

\caption{Big-step semantics for the extended language}
\label{fig:bigstep_semantics}
\end{figure}

% Extensions of the evaluator monad with environments
% Implementation of VLambda and extension of CValues

\section{Testing}
A specifically stated requirement from the 3gERP-team was that every
project team must perform unit tests of the extensions that they
produce. To meet this end we have created unit tests of the parser
module and the evaluator module using the \emph{HUnit} framework.

The tests of the parser each compare a piece of csl syntax with a
directly constructed AST\footnote{Abstract Syntax Tree}.  The tests
deal with the parsing of

\begin{itemize}

  \item value bindings

  \item function application

  \item lambda definitions

  \item type annotations

\end{itemize}

The tests we have performed are only constructive, in the sense that
only valid pieces of syntax are tested to parse to their expected
ASTs.

\chapter{Conclusion}
We have extended the Contract Specification Language of the POETS
platform to include primitives for writing lambda expressions,
conditional expressions, as well as defining named values which includes
functions as well as built-in list manipulation primitives. Given these
extensions, we have established a solid foundation for providing rich
functionality through the expression language, which will give more
flexibility in contract specifications.
Finally, the core features of the original language \cite[page
4]{hvitved10} have been preserved in the extended language.

%While a large portion of the extensions have been tested and verified
%the type checking is still of unknown stability, as the constraint
%solver for the CSL type inferer is not yet implemented at the time of
%writing.

\section{Future work}
As we have worked with the language we have had additional ideas to
features that could be \textit{nice to have} in the contract language.

\begin{itemize}
\item A module system.
\item \lstinline{let}-bindings in expressions (syntactic sugar for
  lambda binding variable)
\item Additional datatypes, for example pairs. To provide a richer
  library of primitive datatypes.
\item Repeat-loop to repetitive clauses (e.g. an action that has to be
  taken every 14 days). The purpose would be to give a better
  intuitive understanding of recursive clause templates. As such, this
  extension would be implemented as purely syntactic sugar.
\item Elimination of parameter-passing \lstinline{where}-clauses.
\end{itemize}

\defbibheading{bibliography}{\chapter{Bibliography}}
\printbibliography


\newpage
\appendix
\chapter{sale\_partial\_delivery.csl: Contract for partial deliveries}
\label{chap:sale_partial_delivery}
\lstinputlisting{sale_partial_delivery.csl}

% \chapter{Motivating cases}

% \paragraph{Example 1 - Syntactic sugar for recursive contracts.}
% Story: Defining recursive contracts can be complicated to define, take
% up much space and are hard to read. We now propose syntactic sugar for
% defining recursive functions as iterative contracts using
% repeat-until/collect-until syntax:

% \begin{lstlisting}
% repeat <a> A(...)
%     within e_{1} after e_{2}
% as d until P(d)
% \end{lstlisting}
% alternatively
% \begin{lstlisting}
% collect <a> A(...)
%     within e_{1} after e_{2}
% in d until P(d)

% for d being a list of some accumulated elements
%      P() being a predicate or list operation.
% \end{lstlisting}     
% Since the semantics dictate collecting of actions, where a condition is met, in
% ‘d’, until predicate P(d) == T, the collect-until gives a better intuitive
% understanding of it’s functionality.
% The repeat-until/collect-until is equivalent to the following construction:
% \begin{lstlisting}[escapechar=\#]
% repeat(accumulator: #$\tau$#, x: #$\tau’$#, y: #$\tau’$#)
%     <a> A(...) @ t
%         within x after y
%     then     if P(A({...} : accumulator)
%         then empty
%         else rep(A({...}: accumulator, x+y-t, 0)
% \end{lstlisting}

% \paragraph{Example 2 - syntactic sugar for parameter-transferring “where”-clauses in contracts.}
% Story: Existing “where”-clauses are bloated and verbose. We propose syntactic sugar to alleviate this problem and make the clause simpler and more concise:

% \begin{lstlisting}
% <seller> A(resource r == goods, receiver b == buyer)
% \end{lstlisting}
% is interpreted as the old construction:
% \begin{lstlisting}
%     <seller> A(resource r, receiver b)
%         where     r == goods andalso
%             b == buyer
% \end{lstlisting}

% Note also, that the where clause will still be possible to use in the ‘syntactic
% sugar’-version, where comparisons are more complicated, such as:

% \begin{lstlisting}
% <seller> A(resource r == goods, receiver b == buyer, amount a)
%         where a = 1.1 * (amount / 2)
% \end{lstlisting}

% for A being some action, e.g. transferAndDeliver.


% \paragraph{Example 3 - Extended expression language and list operators.}
% Story: Consider a scenario where a customer B wants her goods to be delivered in
% portions of all fragile wares separated from heavy-duty wares, but in the same
% contract. This is not immediately possible in the existing system, and can in
% cases of more complex separations of all the goods lead to very complex and
% hard-to-read contracts. We now propose predicates with list operators following
% the template:

% \begin{lstlisting}
% <seller> Deliver(receiver b == customer, resource r)
%     where r == q(goods) p

% for q being a list operator, e.g. 'all'.
%      p being a list predicate, e.g. \x.x == fragile (lambda x where x == fragile)
% \end{lstlisting}

% \paragraph{Example 4 - date arithmetic.}
% Story: Contract templates allow only relative dates for fields such as
% deadlines. An instantiation of a contract will not always be worthwhile, when
% deadlines are set to be specific dates, as all arithmetic of constructing
% relative times from an absolute date is time consuming and not handled by the
% system. We introduce simple date arithmetic to allow the system to perform
% run-time conversion of absolute dates to relative time measures.

% \begin{lstlisting}
% Contract sale : Sale =
%     SaleMult(deliveryDate - startDate, ...)
% \end{lstlisting}

% During interpretation of this expression, deliverDate - startDate, is evaluated
% to a relative measure for the field deliveryDeadline, to comply with the
% contract language constraints regarding handling of dates.


% \subsection{Case 1}
% Story: Concrete contract case using list predicates, added syntactic sugar for
% “where”-clauses and contract templates using date arithmetic and list operators.
% \begin{itemize}
% \item Seller agrees to transfer and deliver to buyer. The goods: 1 bed (king
% size), 1 chair, 1 box of wine glass.
% \item The bed and chair, being heavy duty, must be delivered on or before
% 2010-08-27. The box of wine glass, being fragile, must be delivered before
% 2010-08-30 but after 2010-08-27. All goods are summing to the price of 2000 USD.
% \item All goods must be paid after first delivery.
% \end{itemize}
% Before we present the implementations of the system, we will provide the contract and contract instantiation template for the above contract definition.

\end{document}
